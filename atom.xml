<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-30T02:45:52.105Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Yangrushuai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解计算机系统笔记</title>
    <link href="http://example.com/2021/06/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2021/06/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-06-27T13:13:37.000Z</published>
    <updated>2021-06-30T02:45:52.105Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image001-4971512.jpg" alt="img"></p><p><strong>摘 要</strong></p><p>​    本文主要阐述并分析了Hello World从C语言生成到程序运行结束过程中的一系列过程。包括编译器下预处理，编译，汇编，链接各个过程中Hello World的变化；分析了计算机如何管理进程，Shell如何使Hello World得以加载到内存中执行；计算机的内存管理系统如何高效地对Hello World的地址进行管理；并从万物皆文件的角度来观察Hello World。</p><p><strong>关键词：</strong>C语言，预处理，编译，链接，进程，MMU，文件，内存，CPU，Shell.           </p><p><strong>目 录</strong></p><p><a href="#_Toc532238396">第1章 概述…………………………………………………………………………………………………. - 4 -</a></p><p><a href="#_Toc532238397">1.1 Hello简介…………………………………………………………………………………………… - 4 -</a></p><p><a href="#_Toc532238398">1.2 环境与工具………………………………………………………………………………………….. - 4 -</a></p><p><a href="#_Toc532238399">1.3 中间结果……………………………………………………………………………………………… - 4 -</a></p><p><a href="#_Toc532238400">1.4 本章小结……………………………………………………………………………………………… - 4 -</a></p><p><a href="#_Toc532238401">第2章 预处理……………………………………………………………………………………………… - 5 -</a></p><p><a href="#_Toc532238402">2.1 预处理的概念与作用……………………………………………………………………………. - 5 -</a></p><p><a href="#_Toc532238403">2.2在Ubuntu下预处理的命令………………………………………………………………….. - 5 -</a></p><p><a href="#_Toc532238404">2.3 Hello的预处理结果解析……………………………………………………………………… - 5 -</a></p><p><a href="#_Toc532238405">2.4 本章小结……………………………………………………………………………………………… - 5 -</a></p><p><a href="#_Toc532238406">第3章 编译…………………………………………………………………………………………………. - 6 -</a></p><p><a href="#_Toc532238407">3.1 编译的概念与作用……………………………………………………………………………….. - 6 -</a></p><p><a href="#_Toc532238408">3.2 在Ubuntu下编译的命令…………………………………………………………………….. - 6 -</a></p><p><a href="#_Toc532238409">3.3 Hello的编译结果解析…………………………………………………………………………. - 6 -</a></p><p><a href="#_Toc532238410">3.4 本章小结……………………………………………………………………………………………… - 6 -</a></p><p><a href="#_Toc532238411">第4章 汇编…………………………………………………………………………………………………. - 7 -</a></p><p><a href="#_Toc532238412">4.1 汇编的概念与作用……………………………………………………………………………….. - 7 -</a></p><p><a href="#_Toc532238413">4.2 在Ubuntu下汇编的命令…………………………………………………………………….. - 7 -</a></p><p><a href="#_Toc532238414">4.3 可重定位目标elf格式………………………………………………………………………… - 7 -</a></p><p><a href="#_Toc532238415">4.4 Hello.o的结果解析…………………………………………………………………………….. - 7 -</a></p><p><a href="#_Toc532238416">4.5 本章小结……………………………………………………………………………………………… - 7 -</a></p><p><a href="#_Toc532238417">第5章 链接…………………………………………………………………………………………………. - 8 -</a></p><p><a href="#_Toc532238418">5.1 链接的概念与作用……………………………………………………………………………….. - 8 -</a></p><p><a href="#_Toc532238419">5.2 在Ubuntu下链接的命令…………………………………………………………………….. - 8 -</a></p><p><a href="#_Toc532238420">5.3 可执行目标文件hello的格式……………………………………………………………… - 8 -</a></p><p><a href="#_Toc532238421">5.4 hello的虚拟地址空间…………………………………………………………………………. - 8 -</a></p><p><a href="#_Toc532238422">5.5 链接的重定位过程分析………………………………………………………………………… - 8 -</a></p><p><a href="#_Toc532238423">5.6 hello的执行流程………………………………………………………………………………… - 8 -</a></p><p><a href="#_Toc532238424">5.7 Hello的动态链接分析…………………………………………………………………………. - 8 -</a></p><p><a href="#_Toc532238425">5.8 本章小结……………………………………………………………………………………………… - 9 -</a></p><p><a href="#_Toc532238426">第6章 hello进程管理…………………………………………………………………………… - 10 -</a></p><p><a href="#_Toc532238427">6.1 进程的概念与作用……………………………………………………………………………… - 10 -</a></p><p><a href="#_Toc532238428">6.2 简述壳Shell-bash的作用与处理流程……………………………………………….. - 10 -</a></p><p><a href="#_Toc532238429">6.3 Hello的fork进程创建过程………………………………………………………………. - 10 -</a></p><p><a href="#_Toc532238430">6.4 Hello的execve过程…………………………………………………………………………. - 10 -</a></p><p><a href="#_Toc532238431">6.5 Hello的进程执行………………………………………………………………………………. - 10 -</a></p><p><a href="#_Toc532238432">6.6 hello的异常与信号处理……………………………………………………………………. - 10 -</a></p><p><a href="#_Toc532238433">6.7本章小结……………………………………………………………………………………………. - 10 -</a></p><p><a href="#_Toc532238434">第7章 hello的存储管理……………………………………………………………………….. - 11 -</a></p><p><a href="#_Toc532238435">7.1 hello的存储器地址空间……………………………………………………………………. - 11 -</a></p><p><a href="#_Toc532238436">7.2 Intel逻辑地址到线性地址的变换-段式管理……………………………………….. - 11 -</a></p><p><a href="#_Toc532238437">7.3 Hello的线性地址到物理地址的变换-页式管理………………………………….. - 11 -</a></p><p><a href="#_Toc532238438">7.4 TLB与四级页表支持下的VA到PA的变换………………………………………… - 11 -</a></p><p><a href="#_Toc532238439">7.5 三级Cache支持下的物理内存访问……………………………………………………. - 11 -</a></p><p><a href="#_Toc532238440">7.6 hello进程fork时的内存映射…………………………………………………………… - 11 -</a></p><p><a href="#_Toc532238441">7.7 hello进程execve时的内存映射……………………………………………………….. - 11 -</a></p><p><a href="#_Toc532238442">7.8 缺页故障与缺页中断处理…………………………………………………………………… - 11 -</a></p><p><a href="#_Toc532238443">7.9动态存储分配管理……………………………………………………………………………… - 11 -</a></p><p><a href="#_Toc532238444">7.10本章小结………………………………………………………………………………………….. - 12 -</a></p><p><a href="#_Toc532238445">第8章 hello的IO管理………………………………………………………………………… - 13 -</a></p><p><a href="#_Toc532238446">8.1 Linux的IO设备管理方法………………………………………………………………….. - 13 -</a></p><p><a href="#_Toc532238447">8.2 简述Unix IO接口及其函数……………………………………………………………….. - 13 -</a></p><p><a href="#_Toc532238448">8.3 printf的实现分析………………………………………………………………………………. - 13 -</a></p><p><a href="#_Toc532238449">8.4 getchar的实现分析…………………………………………………………………………… - 13 -</a></p><p><a href="#_Toc532238450">8.5本章小结……………………………………………………………………………………………. - 13 -</a></p><p><a href="#_Toc532238451">结论……………………………………………………………………………………………………………. - 14 -</a></p><p><a href="#_Toc532238452">附件……………………………………………………………………………………………………………. - 15 -</a></p><p><a href="#_Toc532238453">参考文献…………………………………………………………………………………………………….. - 16 -</a></p><h1 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h1><h2 id="1-1-Hello简介"><a href="#1-1-Hello简介" class="headerlink" title="1.1 Hello简介"></a>1.1 Hello简介</h2><p>Hello P2P : 对一个HelloWorld而言，首先先从Hello.c文件，通过预处理、编译、汇编、链接等一系列过程生成可执行文件，得到P（即Process），各类Shell命令处理器调用Fork，生成一个子进程再调用execve系统函数，将HelloWorld加载到内存中执行, 最终在屏幕打印HelloWorld，结束进程。</p><p>Hello 020 : Hello可执行文件加载到内存，CPU生成各类数据结构来维护程序的运行，这是从0到有。程序运行结束之后，父进程回收子进程，内核删除相关的数据结构，释放堆栈等一系列子进程有关的空间，这是从有到无。</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image002-4971512.png" alt="img"></p><h2 id="1-2-环境与工具"><a href="#1-2-环境与工具" class="headerlink" title="1.2 环境与工具"></a>1.2 环境与工具</h2><p>​    环境：</p><p>​    1.4 GHz Quad-Core Intel Core i5 Processor</p><p>​    8 GB 2133 MHz LPDDR3 Memory</p><p>​    Intel Iris Plus Graphics 645 1536 MB Graphics</p><p>​    macOS Big Sur Version 11.2.3,Virtual box ubuntu 16.04</p><p>工具 ： GDB调试， GCC，Readelf,  Valgrind。</p><h2 id="1-3-中间结果"><a href="#1-3-中间结果" class="headerlink" title="1.3 中间结果"></a>1.3 中间结果</h2><p>hello.i 预处理之后的文本文件。</p><p>hello.s 汇编后的文本文件。</p><p>hello.o 可重定位文件hello.o。</p><p>hello 从hello.o链接而成的可执行目标文件。</p><p>Oelf.d 由可重定位目标文件hello.o生成的elf文件。</p><p>Aelf.txt 由可执行目标文件hello生成的elf文件。</p><p>Oobj 由可重定位目标文件hello.o反汇编得到的文件。</p><p>Aobj 由可执行目标文件hello反汇编得到的文件。</p><h2 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h2><p>Hello的产生这一系列的过程是所有的程序的必经之路，包括编译器的努力，内存的分配，CPU的工作等。下面来依依讲解这些内容。</p><h1 id="第2章-预处理"><a href="#第2章-预处理" class="headerlink" title="第2章 预处理"></a>第2章 预处理</h1><h2 id="2-1-预处理的概念与作用"><a href="#2-1-预处理的概念与作用" class="headerlink" title="2.1 预处理的概念与作用"></a>2.1 预处理的概念与作用</h2><p>C预处理器（C Pre-Processor）也常简写为 CPP，是一个与 C 编译器独立的小程序，在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程， C语言的预处理主要有三个方面的内容： 宏定义 、文件包含、条件编译。预处理命令以符号“#”开头，预处理器可以得到.i文件。</p><p>预处理作用：C预处理器扩展源代码，插入所有用#include命令指定的文件，并扩展所有用#define声明指定的宏；有选择性地执行相应操作(如ifdef)，防止宏替换内容（如文件等）的重复包含; 定义宏 #define 和宏删除 #undef。</p><h2 id="2-2在Ubuntu下预处理的命令"><a href="#2-2在Ubuntu下预处理的命令" class="headerlink" title="2.2在Ubuntu下预处理的命令"></a>2.2在Ubuntu下预处理的命令</h2><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image003-4971512.png" alt="img"></p><h2 id="2-3-Hello的预处理结果解析"><a href="#2-3-Hello的预处理结果解析" class="headerlink" title="2.3 Hello的预处理结果解析"></a>2.3 Hello的预处理结果解析</h2><p>include &lt;stdio.h&gt;等三个头文件消失，替代的是一大段代码，描述的是运行库在计算机中的位置，main函数的内容基本不变，方便下一步翻译成汇编语言。</p><h2 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h2><p>预处理是程序运行中不可缺少的步骤，只有通过预处理之后的文件才能被编译器进行。该章阐述了预处理的概念和作用。</p><h1 id="第3章-编译"><a href="#第3章-编译" class="headerlink" title="第3章 编译"></a>第3章 编译</h1><h2 id="3-1-编译的概念与作用"><a href="#3-1-编译的概念与作用" class="headerlink" title="3.1 编译的概念与作用"></a>3.1 编译的概念与作用</h2><p>编译器 (ccl)可以将文本文件hello.i 翻译成文本文件hello.s, .s包含一个汇编语言程序，可以把用高级程序设计语言书写的源程序，翻译成更底层的机器语言的目标程序。</p><h2 id="3-2-在Ubuntu下编译的命令"><a href="#3-2-在Ubuntu下编译的命令" class="headerlink" title="3.2 在Ubuntu下编译的命令"></a>3.2 在Ubuntu下编译的命令</h2><p>gcc -S hello.c -o hello.s</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image004-4971512.png" alt="img"></p><h2 id="3-3-Hello的编译结果解析"><a href="#3-3-Hello的编译结果解析" class="headerlink" title="3.3 Hello的编译结果解析"></a>3.3 Hello的编译结果解析</h2><p><strong>下面分析对各种C数据类型和运算与汇编语言的对应关系：</strong></p><p>3.3.1. 常量：常量包括字符串，整型，浮点型常量，编译器将常量存储在.rodata中，通过相对地址寻址获取值。<br> <img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image005-4971512.png" alt="img"></p><p>3.3.2  变量与赋初值/不赋初值: 初始化的全局变量和静态变量保存在.data段，局部变量保存在堆栈段，未初始化的全局变量和静态变量存在.bss和.COM，各种运算的操作是通过寻址来获取相应的值。</p><p>3.3.3 表达式和赋值=： 常量直接运算，如果是变量求值则配合add , sub , inc, leaq ，movslq(转换)等操作完成，浮点数使用%yumm相关寄存器。</p><p>3.3.4 类型： 编译器识别不同类型的数据选择不同的机器指令来执行。</p><p>3.3.5 宏： 编译器会消除宏定义</p><p>3.3.6 逗号操作符: 在变量声明语句、函数调用中，逗号是做分隔符用的，逗号连接表达式：<img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image006-4971512.png" alt="img"></p><p>得到：<img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image007-4971512.png" alt="img"></p><p>3.3.7类型转换(隐式或显式) ： 隐式类型转换的规则：signed会转换为unsigned，若运算数中有double型或float型，则其他类型数据均转换成double类型进行运算。若运算数中最长的类型为long型．则其他类型数均转换成long型数。若运算数中最长类型为int型，则char型也转换成int型进行运算。显式转换由程序员定义。</p><p>3.3.8: Sizeof， 返回一个unsigned int 类型的值，表示该变量的大小，编译器直接计算出这个值当作常量。</p><p>3.3.9: + - * / % ++ – 取正/负+- 复合“+=”分别对应add , sub , imul/mul , div/ div , dec , inc, 复合+= 目的地址是原地址，例如 leaq 5(%rax) , %rax;</p><p>3.3.10:逻辑&amp;&amp; || ! 编译器会进行多次比较来进行操作，例如：<img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image008-4971512.png" alt="img">编译器翻译成：<img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image009-4971512.png" alt="img"></p><p>3.3.11 位 &amp; | ~ ^  ： 编译器使用 and , or, not, xor 。</p><p>3.3.12移位&gt;&gt;  &lt;&lt;  编译器使用SAL，SHL,SAR, SHR.</p><p>3.3.13复合操作如 “|=” 或“&lt;&lt;=”等,和| &lt;&lt; 一样，只是目的地址是左边的符号的地址。</p><p>3.3.14数组/指针/结构操作：A[i]  &amp;v  *p   s.id  p-&gt;id</p><p>编译器使用M[ imm * R[] + R[]]l来访问数组，指针的值，例如：movl L1.(, %rdi, 4) , %rax. 结构体和数组一样顺序存储，并且保持对齐原则。</p><p>3.3.15: 控制转移 : if/ else while, do, while 等控制语句通过comp 语句和相关jmp指令的配合使用进行跳转，例如：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image010-4971512.png" alt="img"></p><p>语句将-20(%rsp)地址的值和3进行比较，je如果等于就跳转到.L2处，否则执行34行的指令。</p><p>3.3.16 ： 函数调用和函数返回，参数传递(地址/值)。参数可以通过寄存器或栈帧进行传递，在函数调用的时候，参数会依次存在%rdi,%rsi,%rdx,%rcx, %r8,%r9中，如果大于6个参数，后面的参数用栈进行保存。函数调用的时候会在栈上开辟一段空间供函数使用，函数返回的时候恢复栈帧并将返回值赋给%rax。</p><h2 id="3-4-本章小结"><a href="#3-4-本章小结" class="headerlink" title="3.4 本章小结"></a>3.4 本章小结</h2><p>编译器将高级程序翻译成对应的汇编指令，为汇编器进一步翻译成二进制机器指令作铺垫。值得一提的是，编译器会提供各种不同的优化策略，例如O3，O2，Og优化使汇编代码变得更高效。</p><h1 id="第4章-汇编"><a href="#第4章-汇编" class="headerlink" title="第4章 汇编"></a>第4章 汇编</h1><h2 id="4-1-汇编的概念与作用"><a href="#4-1-汇编的概念与作用" class="headerlink" title="4.1 汇编的概念与作用"></a>4.1 汇编的概念与作用</h2><p>​    汇编器（as）将汇编语言书写的程序翻译成与之等价的机器指令的，汇编器把这些指令打包成可重定位目标程序的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含的是程序的指令编码。</p><h2 id="4-2-在Ubuntu下汇编的命令"><a href="#4-2-在Ubuntu下汇编的命令" class="headerlink" title="4.2 在Ubuntu下汇编的命令"></a>4.2 在Ubuntu下汇编的命令</h2><p>​    gcc -c hello.c -o hello. o .需要用readelf 来查看.o 文件</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image011-4971512.png" alt="img"></p><h2 id="4-3-可重定位目标elf格式"><a href="#4-3-可重定位目标elf格式" class="headerlink" title="4.3 可重定位目标elf格式"></a>4.3 可重定位目标elf格式</h2><p> 命令行下输入： readelf -a hello.o :</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image012-4971512.png" alt="img"></p><p>ELF头</p><p>首先显示的是ELF 头，描述了字节大小和顺序，ELF 头的大小，Type 是目标文件类型，机器类型Machine, 节头部表的偏移和大小，下面还有节头部表，他描述了每个节的大小，位置等信息：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image013-4971512.png" alt="img"></p><p>​    节头部表</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image014-4971512.png" alt="img"></p><p>symtab表</p><p>.text：已编译程序的机器代码,main函数的机器指令就在这里。</p><p>.rodata：只读数据，比如printf语句中的格式式串和开关语句的跳转表。</p><p>.data：已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在.data节中，也不出现在.bss节中。</p><p>.bss：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0。</p><p>.symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息..symtab符号表不包含局部变量的条目。</p><p>.rel.text：一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。</p><p>.rel.data：被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。</p><h2 id="4-4-Hello-o的结果解析"><a href="#4-4-Hello-o的结果解析" class="headerlink" title="4.4 Hello.o的结果解析"></a>4.4 Hello.o的结果解析</h2><p>objdump -d -r hello.o hello.o的反汇编如下：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image015-4971512.png" alt="img"></p><p>hello.o的反汇编代码</p><p>与第3章的 hello.s相比，objdump反汇编得到的代码会有汇编代码于机器代码对应，例如48 89 c6 对应于 mov %rax ,%rsi 这个操作。在.s文件中，call调用函数后是一个函数名：Call puts@PLT; 而在反汇编中，5d行的call后是下一条指令的地址（虽然不是最终的地址，但是我们能知道寻址的方法，在可执行文件中我们才能知道最终地址是什么，后面我们会讲到），许多函数要从链接的库中调用，call将他们的相对地址全都设置为0，在.rela.text中设置重定位条目，链接之后得到在内存中的地址。</p><h2 id="4-5-本章小结"><a href="#4-5-本章小结" class="headerlink" title="4.5 本章小结"></a>4.5 本章小结</h2><p>汇编器将.s翻译成机器语言指令，结果保存在.o文件中，linux下可以通过readelf 来查看.o文件的内容，.o文件可以与其他目标文件一起链接成可执行文件。</p><h1 id="第5章-链接"><a href="#第5章-链接" class="headerlink" title="第5章 链接"></a>第5章 链接</h1><h2 id="5-1-链接的概念与作用"><a href="#5-1-链接的概念与作用" class="headerlink" title="5.1 链接的概念与作用"></a>5.1 链接的概念与作用</h2><p><strong>链接</strong>（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时（load time），也就是在程序被加载器（load-er）加载到内存并执行时；甚至执行于运行时（runtime），也就是由应用程序来执行。在现代系统中，链接是由叫做链接器（linker）的程序自动执行的。它能够将各种代码和数据片段收集并组合成为一个单一文件，最终被执行。链接的步骤分别为符号解析和重定位。</p><h2 id="5-2-在Ubuntu下链接的命令"><a href="#5-2-在Ubuntu下链接的命令" class="headerlink" title="5.2 在Ubuntu下链接的命令"></a>5.2 在Ubuntu下链接的命令</h2><p>使用：ld -o hello -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o /usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/crtn.o <strong>hello.o</strong></p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image016-4971512.png" alt="img"></p><h2 id="5-3-可执行目标文件hello的格式"><a href="#5-3-可执行目标文件hello的格式" class="headerlink" title="5.3 可执行目标文件hello的格式"></a>5.3 可执行目标文件hello的格式</h2><p>简要分析hello的ELF格式，包括各段的起始地址，大小等信息。用指令readelf -a hello 查看文件信息，与.o的ELF 格式有所不同，可执行目标文件的格式为：</p><img src="/.com//content/深入理解计算机系统/clip_image017-4971512.png" alt="img" style="zoom:50%;"><p>符号表，调试信息节头部表不包含在可执行文件中，而是增加了.init，.fini，.plt，.plt.got等节，分别是程序初始化执行的代码，程序终止时需要执行的代码，动态链接中的过程连接表，动态链接中的全局偏移表。</p><p>可执行文件的指令地址经过链接器的重定位之后被确定了下来，例如main函数：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image018-4971512.png" alt="img"></p><p>表明main函数的入口位置在0x4011b6处。</p><h2 id="5-4-hello的虚拟地址空间"><a href="#5-4-hello的虚拟地址空间" class="headerlink" title="5.4 hello的虚拟地址空间"></a>5.4 hello的虚拟地址空间</h2><p>  使用gdb加载hello, 在gdb 下运行layout asm 然后设置断点b main,查看main函数的地址：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image019-4971512.png" alt="img"></p><p>5.3的分析无误。</p><h2 id="5-5-链接的重定位过程分析"><a href="#5-5-链接的重定位过程分析" class="headerlink" title="5.5 链接的重定位过程分析"></a>5.5 链接的重定位过程分析</h2><p>现在要分析hello与hello.o的不同，使用objdump -d -r hello查看可执行文件的反汇编信息：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image020-4971512.png" alt="img"></p><p>可以看到，与之前.s 和.o文件不同的是4011d6行的指令Callq 有了合法的虚拟地址，而不是用0 或者单个函数来表示，说明链接之后的可执行文件可以直接载入到内存中。</p><p>静态链接的过程：为了完成链接任务，链接器必须完成两个主要任务，首先要先进行符号解析，将目标文件引用的符号和定义的符号关联起来，如果有静态链接库.a文件，则需要关联.o中引用的.a中的符号。如果是全局符号的情况，编译器会假设符号会在其他模块中定义，这时候会生成一些符号表条目让链接器来处理，链接器拿到多个.o文件的符号表，对每一个符号考虑强弱，优先关联强符号，不允许有同名的强符号，没有强符号任意选择一个弱符号。</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image021-4971512.png" alt="img"></p><p>接下来是<strong>重定位</strong>：</p><p>汇编器生成一个目标模块时，只解析符号的话是不知道数据和代码最终将放在内存中的什么位置的。也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中。已初始化数据的重定位条目放在.rel.data中。</p><p>下面结合hello.o的重定位项目，分析hello中对其怎么重定位的。</p><p>ELF 定义了32种不同的重定位类型，但目前接触到的方法主要是两种，一种是R_X86_64_PC32，即PC相对寻址：重定位一个使用32位PC相对地址的引用。它利用的是一个PC相对地址就是距程序计数器（PC）的当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，就将在指令中编码的32位值加上PC的当前运行时值，得到有效地址（如call指令的目标），PC值通常是下一条指令在内存中的地址。</p><p>R_X86_64_32，即绝对寻址：重定位一个使用32位绝对地址的引用。通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。</p><p><strong>1.重定位PC相对引用</strong></p><p><strong>refaddr=ADDR（s）+ r.offset;</strong></p><p>*<strong>refptr=(unsigned)(ADDR(r.symbol) + r.addend-refaddr</strong></p><p><strong>2.重定位PC绝对引用</strong></p><p>*<strong>refptr=(unsigned)(ADDR(r.symbol)+r.addend);</strong></p><p><strong>其中s是对应的节，r是符号对应的重定位条目。</strong></p><h2 id="5-6-hello的执行流程"><a href="#5-6-hello的执行流程" class="headerlink" title="5.6 hello的执行流程"></a>5.6 hello的执行流程</h2><p>使用GDB，说明从加载hello到_start，到call main,以及程序终止的所有过程。列出执行hello其调用与跳转的各个子程序名或程序地址。</p><p>Step1 :gdb 查看所有函数：</p><img src="/.com//content/深入理解计算机系统/clip_image022-4971512.png" alt="img" style="zoom: 50%;"><p>Step2 ： 对每一个函数依次设置断点：</p><img src="/.com//content/深入理解计算机系统/clip_image023-4971512.png" alt="img" style="zoom:50%;"><p>Step3 ：gdb 下输入layout asm 后 再输入r 运行程序：</p><img src="/.com//content/深入理解计算机系统/clip_image024-4971512.png" alt="img" style="zoom:50%;"><p>0x00000000004010d0 in &lt;_start&gt;</p><p>0x7ffff7deafc0 &lt;_libc_start_main&gt;</p><p>0x0000000000401240 in __libc_csu_init ()</p><p>0x00000000004011b0 in frame_dummy ()</p><p>0x0000000000401140 in register_tm_clones ()</p><p>0x00000000004011b6 in main ()</p><p>0x7ffff7e4b5a0 &lt;__GI__IO_puts&gt;       // 打印字符串  </p><p>0x7ffff7e0dbc0 &lt;__GI_exit&gt;</p><p>0x0000000000401180 in __do_global_dtors_aux ()</p><p>0x0000000000401110 in deregister_tm_clones ()</p><p>0x00000000004012b8 in _fini ()</p><h2 id="5-7-Hello的动态链接分析"><a href="#5-7-Hello的动态链接分析" class="headerlink" title="5.7 Hello的动态链接分析"></a>5.7 Hello的动态链接分析</h2><p>下面分析hello程序的动态链接项目，通过gdb调试，分析在dl_init前后，这些项目的内容变化:</p><p>首先看动态链接的定义： 在运行或加载是，加载共享库到任意的内存地址，并和一个在内存中的程序链接起来的过程：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image025-4971512.png" alt="img"></p><p>​    在dl_init前， PIC函数调用的目标地址都实际指向PLT中的代码逻辑，初始时每个GOT条目都指向对应的PLT条目的第二条指令。</p><p>​    当某个动态链接函数第一次被调用，会先进入对应的PLT条目，然后PLT指令跳转到对应的GOT条目中，其内容是PLT的下一条指令。然后将函数的ID压入栈中后跳转到PLT[0]。PLT[0]通过GOT[1]将动态链接库的一个参数压入栈中，再通过GOT[2]间接跳转进动态链接器中。动态链接器使用两个栈条目来确定函数的运行时位置，用这个地址重写GOT[4]，然后再次调用函数。经过上述操作，再次调用时PLT[2]会直接跳转通过GOT[4]跳转到函数而不是PLT[2]的下一条地址，这就是GOT的运行机制，它很好地利用了地址相对位置不变机制来设计GOT。</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image026-4971512.png" alt="img"></p><p>dl_init运行前</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image027-4971512.png" alt="img"></p><p>dl_init运行后</p><h2 id="5-8-本章小结"><a href="#5-8-本章小结" class="headerlink" title="5.8 本章小结"></a>5.8 本章小结</h2><p>分析hello.o进行链接得到了可执行目标文件hello，分析hello的ELF格式，观察动态链接中dl_init 前后GOT值的变化，可以看出将各种代码和数据片段收集并组合成为一个单一文件确实是一个复杂的过程。<br> <strong>第6章 hello进程管理</strong></p><h2 id="6-1-进程的概念与作用"><a href="#6-1-进程的概念与作用" class="headerlink" title="6.1 进程的概念与作用"></a>6.1 进程的概念与作用</h2><p>进程是一个执行中程序的实例，是程序及其数据在CPU下顺序执行时所发生的活动，进程是具有独立功能的程序在数据集上运行的过程，它是系统进行资源分配和调度的一个独立单位。它可以使CPU并行完成任务，并高效利用内存和CPU。</p><h2 id="6-2-简述壳Shell-bash的作用与处理流程"><a href="#6-2-简述壳Shell-bash的作用与处理流程" class="headerlink" title="6.2 简述壳Shell-bash的作用与处理流程"></a>6.2 简述壳Shell-bash的作用与处理流程</h2><p>Linux系统中，Shell是一个交互型应用级程序，代表用户运行其他程序(是命令行解释器，以用户态方式运行的终端进程)。</p><p>其基本功能是解释并运行用户的指令，重复如下处理过程： </p><p>(1)终端进程读取用户由键盘输入的命令行。 </p><p>(2)分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量。</p><p>(3)检查第一个(首个、第0个）命令行参数是否是一个内置的shell命令。</p><p>(3)如果不是内部命令，认为是一个可执行文件，则调用fork( )函数创建一个新进程/子进程。如果是内部命令则执行内部命令。</p><p>(4)在子进程中，用步骤2获取的参数，调用execve( )执行指定程序。</p><p>(5)如果用户没要求后台运行(命令末尾没有&amp;号）否则shell使用waitpid（或wait…)等待作业终止后返回。</p><p>(6)如果用户要求后台运行(如果命令末尾有&amp;），则shell返回。</p><h2 id="6-3-Hello的fork进程创建过程"><a href="#6-3-Hello的fork进程创建过程" class="headerlink" title="6.3 Hello的fork进程创建过程"></a>6.3 Hello的fork进程创建过程</h2><p>需要引入unistd.h，这时可以调用fork函数获取pid，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span> )<span class="built_in">printf</span>(<span class="string">&quot;it is son&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;\nit is parent&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个简单的例子有一些微妙的方面：</p><p>fork调用一次，返回两次。fork函数被父进程调用一次，但是却返回两次，一次返回到父进程，一次是返回到新创建的子进程。</p><p>并发执行 ：父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。在我们的系统上运行这个程序时，父进程先完成它的printf语句，然后是子进程。然而，在另一个系统上可能正好相反。一般而言，</p><p>作为程序员，决不能对不同进程中指令的交替执行做任何假设。</p><p>两个进程的地址空间相同但是独立。如果能够在fork函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。例如，当fork函数返回时，本地变量在父进程和子进程中都相同。然而，因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。后面，父进程和子进程对本地变量所做的任何改变都是独立的，不会反映在另一个进程的内存中。这就是为什么当父进程和子进程调用它们各自的printf语句时，它们中的变量x会有不同的值。</p><p>进程共享文件。当运行这个示例程序时，我们注意到父进程和子进程都把它们的输出显示在屏幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用fork时，stdout文件是打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。</p><h2 id="6-4-Hello的execve过程"><a href="#6-4-Hello的execve过程" class="headerlink" title="6.4 Hello的execve过程"></a>6.4 Hello的execve过程</h2><p>execve函数在当前进程的上下文中加载并运行一个新程序：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image028-4971512.png" alt="img"></p><p>execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序，并返回-1。所以，与fork一次调用返回两次不同，execve调用一次并从不返回。</p><p>后面接着是参数列表argv[]，argv变量指向一个以null结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例，argv[0]是可执行目标文件的名字。环境变量的列表是由一个类似的数据结构表示的，如图8-21所示。envp变量指向一个以null结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如“name=value”的名字-值对。</p><p>execve函数加载并运行hello并替代原程序主要有以下几个步骤：</p><p>1.删除已存在的用户区域： 删除当前进程虚拟地址的用户部分中的已存在的区域结构。映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。</p><p>2.映射共享区域 ：如果hello程序与共享对象（或目标）链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</p><p>3.设置程序计数器（PC）：execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。</p><p>之后调度器在下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。</p><h2 id="6-5-Hello的进程执行"><a href="#6-5-Hello的进程执行" class="headerlink" title="6.5 Hello的进程执行"></a>6.5 Hello的进程执行</h2><p>进程是在上下文中运行的，每一个程序都运行在某个进程的上下文中，上下文包括了进程运行所需的各种对象的值，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构。通常情况下，CPU会“同时”执行多个进程，即所谓的并发流(concurrent flow)，并发流的实现依赖于上下文的切换，上下文切换主要有三个步骤：</p><p>1.保存当前进程的上下文。</p><p>2.恢复某个先前被抢占的进程被保存的上下文。</p><p>3.将控制传递给这个新恢复的进程。</p><p>上下文切换中，控制会从用户模式移交给内核模式，内核模式比用户模式的权限更大，它能够执行指令集中的任何指令，访问系统中的任何位置，这些权限在上下文切换中是需要的，切换完毕之后控制才会重新移交给用户模式。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度（scheduling），是由内核中称为调度器（scheduler）的代码处理的。当内核选择一个新的进程运行时，我们就说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用上下文切换机制来将控制转移到新的进程。</p><p>当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，如果Hello 使用scanf()想要读取用户输入的字符串，内核可以选择执行上下文切换，运行另外一个进程，而不是一直等待直到用户按回车。另一个示例是sleep系统调用，它显式地请求让调用进程休眠。一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。</p><p>中断也可能引发上下文切换。比如，所有的系统都有某种产生周期性定时器中断的机制，通常为每1毫秒或每10毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。</p><h2 id="6-6-hello的异常与信号处理"><a href="#6-6-hello的异常与信号处理" class="headerlink" title="6.6 hello的异常与信号处理"></a>6.6 hello的异常与信号处理</h2><h5 id="6-6-1下面来解释异常与信号的处理："><a href="#6-6-1下面来解释异常与信号的处理：" class="headerlink" title="6.6.1下面来解释异常与信号的处理："></a>6.6.1下面来解释异常与信号的处理：</h5><p>什么是信号？信号是一个小信息，它能够通知进程系统中发生了某种类型的事件，不同的信号对应于不同的事件，并且有一个异常处理程序来处理这个信号，它与硬件异常处理程序不同，后者交给内核异常处理程序处理，对用户进程而言是不可见的，而前者提供一种机制来通知用户异常的发生,异常有多种类型，通常有终止，停止，故障，中断几种，异常处理程序会根据异常类型的不同采用默认的异常处理函数。</p><p>信号处理过程主要有两个步骤：</p><p>1.发送信号。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程(可以是自己)。发送信号可以有如下两种原因：1）内核检测到一个系统事件，比如除零错误或者子进程终止。2）一个进程调用了kill函数，显式地要求内核发送一个信号给目的进程。</p><p>2.接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序（signal handler）的用户层函数捕获这个信号。图8-27给出了信号处理程序捕获信号的基本思想。</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image029-4971512.png" alt="img"></p><p>一个发出而没有被接收的信号叫做待处理信号（pending signal）。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都不会排队等待；它们只是被简单地丢弃。一个进程可以有选择性地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。</p><p>一个待处理信号最多只能被接收一次。内核为每个进程在pending位向量中维护着待处理信号的集合，而在blocked位向量中维护着被阻塞的信号集合。只要传送了一个类型为k的信号，内核就会设置pending中的第k位，而只要接收了一个类型为k的信号，内核就会清除pending中的第k位。</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image030-4971512.png" alt="img"></p><p>task_struct 维护一个signal结构体</p><h5 id="6-6-2-观察各命令及运行结果："><a href="#6-6-2-观察各命令及运行结果：" class="headerlink" title="6.6.2 观察各命令及运行结果："></a>6.6.2 观察各命令及运行结果：</h5><p>未修改过的源代码如下：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sleepsecs=<span class="number">2.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> *argc*,<span class="keyword">char</span> **argv*[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Usage: Hello 119xxx0803 yrs！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello %s %s\n&quot;</span>,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">    sleep(sleepsecs);</span><br><span class="line">  &#125;</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>1.</strong> <strong>运行时按下ctrl + Z</strong> <strong>：</strong></p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image031-4971512.png" alt="img"></p><p>注：jobs指令可以查看当前后台程序的执行情况。</p><p>ctrl+Z 按下后，shell父进程发送一个SIGSTP信号，信号处理程序将hello进程挂起，放到后台，停止hello程序。</p><p><strong>2.</strong> <strong>运行时按下ctrl+C :</strong></p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image032-4971512.png" alt="img"></p><p>Ctrl + C 会发送一个SIGINT信号，默认行为是将hello程序终止：</p><p>**3.**<strong>运行时按回车键：</strong></p><p><strong><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image033-4971512.png" alt="img"></strong></p><p>在程序运行的时候按下Enter键，会在屏幕上出现换行，但是不会影响程序的运行。最后的getchar 会缓冲区中读取一个回车键，剩下的回车键等终端结束后会换行。</p><p>**3.**<strong>运行时乱按：</strong></p><p>乱按不会影响程序的运行，但是结束可能会影响shell的下一个指令是什么：</p><p><strong><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image034-4971512.png" alt="img"></strong></p><p>如果我们先让getchar读入一个回车，然后再输入./hello + 回车：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image035-4971512.png" alt="img"></p><p>Shell 会自动启动hello程序，如果是内部命令效果一样,我们在后台挂起两个hello进程，然后在hello运行的时候输入回车 + jobs + 回车得到：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image036-4971512.png" alt="img"></p><p>pstree部分分支查看如下：（bash的进程分支）</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image037-4971512.png" alt="img"></p><p>接着使用fg调出后台程序运行：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image038-4971512.png" alt="img"></p><p>bg后台运行另一个hello程序：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image039-4971512.png" alt="img"></p><h2 id="6-7本章小结"><a href="#6-7本章小结" class="headerlink" title="6.7本章小结"></a>6.7本章小结</h2><p>​    本章介绍了hello程序的加载与运行的过程。计算机为每个程序抽象出一个概念为进程，hello以进程的形式运行，每个进程都处在某个进程的上下文中，每个进程也都有属于自己的上下文，用于操作系统通过上下文切换进行进程调度。而且还展示了hello程序的进程执行和异常与信号处理。</p><h1 id="第7章-hello的存储管理"><a href="#第7章-hello的存储管理" class="headerlink" title="第7章 hello的存储管理"></a>第7章 hello的存储管理</h1><h2 id="7-1-hello的存储器地址空间"><a href="#7-1-hello的存储器地址空间" class="headerlink" title="7.1 hello的存储器地址空间"></a>7.1 hello的存储器地址空间</h2><p>**逻辑地址(Logical Address)**：逻辑地址也叫相对地址，它运用在没有链接前的重定位目标文件中，逻辑地址要经过寻址方式的计算或变换才得到内存储器中的实际有效地址，查看hello.o中的部分反汇编代码可以看到逻辑地址：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image040-4971512.png" alt="img"></p><p>hello.o汇编代码</p><p>计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的<strong>物理地址</strong>( Physical Address)与之对应。例如第一个字节的地址为0，接下来的字节地址为1，再下一个为2，依此类推。CPU访问内存的最自然的方式就是使用物理地址。例如hello要读取从物理地址x处开始的4字节字。当CPU执行这条加载指令时，会生成一个有效物理地址，通过内存总线，把它传递给主存。主存取出从物理地址4处开始的4字节字，并将它返回给CPU，CPU会将它存放在一一个寄存器里。</p><p>但是现代计算机不会直接地访问物理地址，而是采用虚拟寻址的方式进行地址访问，虚拟地址需要经过翻译才能得到物理地址，<strong>线性地址(Linear Address)<strong>是逻辑地址到物理地址变换之间的中间层，</strong>和虚拟地址意思一样。</strong>例如在分段部件中逻辑地址是段中的偏移地址，加上基地址就是线性地址。</p><p>什么是虚拟地址？文件经过重定位之后，能够在内存中访问并运行的地址是<strong>虚拟地址</strong>(Virtual Address)，虚拟地址是现代计算机系统提供的一种对主存的抽象概念。虚拟地址由虚拟内存（VM）来管理，虚拟内存为每个程序提供了一个大的、一致的和私有的地址空间。他将主存看成是一个存储在存盘上的地址空间的高速缓存，为每个进程提供了一致的地址空间，从而简化内存的管理。例如所有的进程包括hello，他们的代码段都是从虚拟地址0x400000（x86-64下）开始的。查看hello中的部分反汇编代码可以看到虚拟地址：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image041-4971512.png" alt="img"></p><h2 id="7-2-Intel逻辑地址到线性地址的变换-段式管理"><a href="#7-2-Intel逻辑地址到线性地址的变换-段式管理" class="headerlink" title="7.2 Intel逻辑地址到线性地址的变换-段式管理"></a>7.2 Intel逻辑地址到线性地址的变换-段式管理</h2><p>​    Base + offset 。例如，mov $0x1, %edi指令，段偏移地址为0x25，如果加载后逻辑偏移地址为0x4011b6，那么最终的线性地址为Base + offset=0x4011db. </p><h2 id="7-3-Hello的线性地址到物理地址的变换-页式管理"><a href="#7-3-Hello的线性地址到物理地址的变换-页式管理" class="headerlink" title="7.3 Hello的线性地址到物理地址的变换-页式管理"></a>7.3 Hello的线性地址到物理地址的变换-页式管理</h2><p>​    线性地址到物理地址的变换涉及到页表和MMU概念。页表是一个页表条目的数组，虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE，PTE中有一个有效位用来表示该区域是否被已缓存在内存中。</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image042-4971512.png" alt="img"></p><p>MMU即分页内存管理单元,MMU位于处理器内核和连接高速缓存以及物理存储器的总线之间,能够将有效地址映射成对应的物理地址，以访问指令和数据。</p><p>当hello需要访问一个内存中的地址时，处理器将虚拟地址发送给MMU，</p><p>MMU利用虚拟地址对应的虚拟页号生成页表项（PTE）地址，并从页表中找到对应的PTE，如果PTE中的有效位为0，则MMU会触发缺页异常。缺页处理程序选择物理内存中的牺牲页（若页面被修改，则换出到磁盘），缺页处理程序调入新的页面到内存，并更新PTE，缺页处理程序返回到原来进程，再次执行导致缺页的指令：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image043-4971512.png" alt="img"></p><h2 id="7-4-TLB与四级页表支持下的VA到PA的变换"><a href="#7-4-TLB与四级页表支持下的VA到PA的变换" class="headerlink" title="7.4 TLB与四级页表支持下的VA到PA的变换"></a>7.4 TLB与四级页表支持下的VA到PA的变换</h2><p>​    TLB介于 CPU 和CPU缓存之间用于缓存一部分标签页表条目，它采用高速缓冲存储器作为页表的Cache，能够加快页表PTE的访问。TLB中保存最近常用的虚拟页号对应的页表条目PTE（含物理页号），MMU 可以直接通过TLB获取PTE中的值，虚拟页数较少的进程页表可以完全在TLB中。 </p><p>​    多级页表可理解为一种时间换空间的技术，设计多个页表来大大降低页表占用的空间。由于原有页表中大量的连续PTE条目都是未分配的，Intel64位CPU采用4级页表后，一级页表的PTE 能够访问到4KB的二级页表，大大节省了页表空间。</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image044-4971512.png" alt="img"> </p><p>给定一个虚拟地址，MMU会分成多个部分，VPN用来访问页表的元素，如果是k级页表，则需要k个VPN来标记访问的每一个页表的虚拟页号，如下图所示：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image045-4971512.png" alt="img"></p><p>最后一级页表保存了PPN，即物理页号，结合物理页面偏移量得到完整的物理地址。</p><p>TLB的访问机制为MMU将VPN分成TLB索引和TLB标记两个部分，TLB索引(TLBI)定位TLB中的行，TLB标记（TLBI）与行中的标记位进行匹配，如果匹配成功说明TLB中有需要的PPN，最后完成VA到PA转换。如果没有则通过多级页表进行访问：</p><img src="/.com//content/深入理解计算机系统/clip_image046-4971512.png" alt="img" style="zoom:50%;"><h2 id="7-5-三级Cache支持下的物理内存访问"><a href="#7-5-三级Cache支持下的物理内存访问" class="headerlink" title="7.5 三级Cache支持下的物理内存访问"></a>7.5 三级Cache支持下的物理内存访问</h2><p>现代计算机采用存储器山的结构进行物理内存的访问：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image047-4971512.png" alt="img"></p><p>首先CPU会在L1中搜索想要的值，如果找到则直接返回想要的值，如果没有找到，则会从下一级Cache中寻找目标值，如果找到则加载到L1中，替换掉L1中已经存在的牺牲页或空白页（根据不同的替换策略）。如果没有找到则访问下一级Cache，原理相同。</p><h2 id="7-6-hello进程fork时的内存映射"><a href="#7-6-hello进程fork时的内存映射" class="headerlink" title="7.6 hello进程fork时的内存映射"></a>7.6 hello进程fork时的内存映射</h2><p>​    fork 函数被shell调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID 。为了给hello进程创建虚拟内存，它创建hello进程的mm_struct 、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork 在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork 时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image048-4971512.png" alt="img"></p><h2 id="7-7-hello进程execve时的内存映射"><a href="#7-7-hello进程execve时的内存映射" class="headerlink" title="7.7 hello进程execve时的内存映射"></a>7.7 hello进程execve时的内存映射</h2><p>在当前进程中的程序执行了execve（”a.out”,NULL, NULL）调用时，execve函数在当前程序中加载并运行包含在可执行文件a.out中的程序，用a.out代替了当前程序。加载并运行a.out主要分为一下几个步骤：</p><p>1.删除已存在的用户区域:删除当前进程虚拟地址的用户部分中的已存在的区域结构；</p><p>2.映射私有区域:为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零；</p><p>3.映射共享区域:hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内；</p><p>4.设置程序计数器（PC）:设置当前进程上下文的程序计数器，使之指向代码区域的入口点。</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image049-4971512.png" alt="img"></p><h2 id="7-8-缺页故障与缺页中断处理"><a href="#7-8-缺页故障与缺页中断处理" class="headerlink" title="7.8 缺页故障与缺页中断处理"></a>7.8 缺页故障与缺页中断处理</h2><p>7.4节已经完成了分析。</p><h2 id="7-9动态存储分配管理"><a href="#7-9动态存储分配管理" class="headerlink" title="7.9动态存储分配管理"></a>7.9动态存储分配管理</h2><p>动态存储分配涉及到对运行时堆的使用，<strong>动态内存分配器</strong>维护着一个进程中的称为堆的虚拟内存区域，brk指向堆的顶部，分配器将堆视为一组不同大小的块的集合来维护，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。</p><p>Hello调用malloc函数，会先访问堆中是否有合适大小的空闲块，如果有相应的空闲块则分配这个块给Hello，返回一个指针指向这个分配块的首地址。如果没有合适的空闲块，系统会拓展堆空间，改变brk的值来保证有合适的空闲块。</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image050-4971512.png" alt="img"></p><h2 id="7-10本章小结"><a href="#7-10本章小结" class="headerlink" title="7.10本章小结"></a>7.10本章小结</h2><p>本章简要分析来程序运行时包括页面管理，高速缓存管理，虚拟地址与实地址的转化全流程以及动态内存分配等内容</p><h1 id="第8章-hello的IO管理"><a href="#第8章-hello的IO管理" class="headerlink" title="第8章 hello的IO管理"></a>第8章 hello的IO管理</h1><h2 id="8-1-Linux的IO设备管理方法"><a href="#8-1-Linux的IO设备管理方法" class="headerlink" title="8.1 Linux的IO设备管理方法"></a>8.1 Linux的IO设备管理方法</h2><center><strong>万物皆文件！</strong></center><p align="right"><strong> ——linux</strong></p><p>设备的模型化与管理：Linux下的所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，一个Linux文件是一个m个字节的序列，所有的输入和输出都被当作对相应文件的读和写。这种设备映射为文件的方式，把各种设备硬件的复杂物理特性的细节屏蔽起来，提供一个对各种不同设备使用统一方式进行操作的接口，这样的接口称为Unix I/O，Unix I/O使得输入和输出都能以一种统一且一致的方式的来执行。</p><h2 id="8-2-简述Unix-IO接口及其函数"><a href="#8-2-简述Unix-IO接口及其函数" class="headerlink" title="8.2 简述Unix IO接口及其函数"></a>8.2 简述Unix IO接口及其函数</h2><p>UnixIO接口提供了一些的函数来对文件进行操作，例如：open、read和write。</p><p>open函数描述如下：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image051-4971512.png" alt="img"></p><p>open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件:O_ RDONLY:只读；O_ WRONLY:只写；O_ RDWR:可读可写。mode参数指定了新文件的访问权限位。例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = Open(<span class="string">&quot;hello. txt&quot;</span>, <span class="number">0</span>_ CREATIO _TRUNCIO_ _WRONLY, DEF MODE) ;</span><br></pre></td></tr></table></figure><p>其余两个函数描述如下：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image052-4971512.png" alt="img"></p><p>fd是文件描述符，例如：</p><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image053-4971512.png" alt="img"></p><p>read函数从标准输入设备中读入一个值，存入c中，然后调用write函数将c输出到标准输出设备。</p><h2 id="8-3-printf的实现分析"><a href="#8-3-printf的实现分析" class="headerlink" title="8.3 printf的实现分析"></a>8.3 printf的实现分析</h2><p>printf函数可以发送格式化输出到标准输出 stdout中，即显示用户想要显示的字符串到屏幕上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">char</span> *va_list</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> **fmt*, ...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  va_list arg = (va_list)((<span class="keyword">char</span>*)(&amp;*fmt*) + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  i = <span class="built_in">vsprintf</span>(buf, *fmt*, arg);</span><br><span class="line"></span><br><span class="line">  write(buf, i);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> **buf*, <span class="keyword">const</span> <span class="keyword">char</span> **fmt*, va_list *args*)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span>&#123; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* p; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> tmp[<span class="number">256</span>]; </span><br><span class="line"></span><br><span class="line">  va_list p_next_arg = args; </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (p=buf;*fmt;fmt++) &#123; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>) </span><br><span class="line">  &#123; </span><br><span class="line">  *p++ = *fmt; </span><br><span class="line">  <span class="keyword">continue</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  fmt++; </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">switch</span> (*fmt) &#123; </span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: </span><br><span class="line">  itoa(tmp, *((<span class="keyword">int</span>*)p_next_arg)); </span><br><span class="line">  <span class="built_in">strcpy</span>(p, tmp); </span><br><span class="line">  p_next_arg += <span class="number">4</span>;</span><br><span class="line">  p += <span class="built_in">strlen</span>(tmp); </span><br><span class="line">  <span class="keyword">break</span>; </span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: </span><br><span class="line">  <span class="keyword">break</span>; </span><br><span class="line">   <span class="keyword">case</span> ....</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (p - buf); </span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure><p>printf()通过调用vsprintf函数来解析字符串中的%参数，然后得到整个字符串的长度之后使用Unix I/O函数write()输出到标准输出设备上。</p><p>其中，arg指向变量参数，例如printf(“hello %d , %s”, i , name); arg 指向第一个参数i。fmt指向”hello %d, %s”这个字符串。</p><p>vsprintf会扫描整个字符串并进行复制直到遇到%（第一个for循环），然后使用swtich对字符串进行修改。</p><p>随后调用write函数，其中会调用一个syscall函数，它会执行一个系统调用，根据指定的参数number和所有系统调用的汇编语言接口来确定调用哪个系统调用，例如触发一个陷阱-系统调用。驱动程序去/proc/devieces中申请得到设备名和主设备号，并使用mknod命令建立设备节点文件。通过主设备号将设备节点文件和设备驱动程序联系在一起，然后利用fops函数，绑定应用层的write和驱动层的write。当应用层写一个设备文件的时候，系统找到对应的设备驱动子程序（驱动程序和设备号一一对应），对于printf而言，字符显示驱动子程序根据ASCII根据字模库更新vram。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="8-4-getchar的实现分析"><a href="#8-4-getchar的实现分析" class="headerlink" title="8.4 getchar的实现分析"></a>8.4 getchar的实现分析</h2><p>getchar()是stdio.h中的库函数，它的作用是从stdin流中读入一个字符。</p><p>用户通过输入设备输入字符串到内存缓冲区，操作系统执行一个异步异常-键盘中断，这个键盘信号处理子程序将接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。</p><h2 id="8-5本章小结"><a href="#8-5本章小结" class="headerlink" title="8.5本章小结"></a>8.5本章小结</h2><p>通过对linux下Unix I/O几个主要函数的阐述分析，讲解了文件的概念及其Unix I/O的原理及其应用。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>​    Hello world的实现是一个复杂的过程，不仅仅涉及到编译器的一系列操作：预处理，编译，汇编，链接…还需要CPU，MMU，内存等硬件，Shell，操作系统和内存管理系统的帮助，Unix I/O接口对文件的支持，最终保证了Hello wold的正确执行。</p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p><img src="/.com//clip_image054-4971512.png" alt="img"></p><p>hello.c 是hello的c语言源程序。</p><p>hello.i 预处理之后的文本文件。</p><p>hello.s 汇编后的文本文件。</p><p>hello.o 可重定位文件hello.o。</p><p>hello 从hello.o链接而成的可执行目标文件。</p><p>Oelf.d 由可重定位目标文件hello.o生成的elf文件。</p><p>Aelf.txt 由可执行目标文件hello生成的elf文件。</p><p>Oobj 由可重定位目标文件hello.o反汇编得到的文件。</p><p>Aobj 由可执行目标文件hello反汇编得到的文件。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1].   (美)索加，班诺拉．MPC5554 5553微处理器揭秘：北京航空航天大学出版社，2010.11：第47页</p><p>[2].   深入理解计算机系统，Computer Systems:A Programmer’s Perspective （美）布赖恩特（Bryant,R.E.） 等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image001-4971512.jpg&quot; alt</summary>
      
    
    
    
    
    <category term="csapp" scheme="http://example.com/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>Cartographer学习笔记</title>
    <link href="http://example.com/2021/05/30/Cartographer/"/>
    <id>http://example.com/2021/05/30/Cartographer/</id>
    <published>2021-05-30T14:14:13.000Z</published>
    <updated>2021-06-16T05:27:48.697Z</updated>
    
    <content type="html"><![CDATA[<p>大二下刚开学和shl一起参加了航天创意物流比赛，刚开始想着两个人去试试水，随便玩一下，后来开学没多久，因为一起参加比赛的另一支队伍缺员，于是两队考虑合并，至此之后就开始有点团队合作来学习了。整个比赛分为好几个部分，我主要负责一些路径规划的东西，因为大二上的时候学过数据结构，做的比较快就开始做SLAM建图，第一次阅读工程代码，同时阅读英文技术文档，说实话还是挺有意思的，最近比较忙，分享一下我没整理的学习笔记。</p><p><strong>Cartographer.</strong></p><p>算法理解:如图所示，可以看到cartographer 主要分为两大部分，一个是用来建立一系列子图(submap)的Local SlAM，算法接受到由传感器从环境中获取的数据，经过Voxel Filter，Voxel Filter的功能是将原始点降采样为恒定大小的多维数据集并且仅保留每个多维数据集的质心进行（用以解决距离数据密度不均匀的问题）, 而Adaptive Voxel Filter顾名思义用来自适应Voxel Filter相关配置（例如voxel_filter_size），处理后的数据组合完毕并从多个范围数据中过滤掉后，就进入Local SLAM。Local SLAM通过使用PoseExtrapolator的初始猜测进行匹配，将新的数据插入其当前子图结构中。PoseExtrapolator背后的想法是使用测距仪之外的其他传感器的传感器数据来预测下一次扫描应插入到子图中的位置，并且，通过调用</p><p>Ceres Solver将寻找最佳匹配位置问题转化成最小二乘问题进行优化，得到一个更匹配的子图。同时在Global SIAM中，它通过对子图进行扫描匹配扫描查找循环闭合约束。当Local SLAM生成其连续的子图时，对子图数据集的全局优化任务在后台运行。它的作用是在彼此之间重新布置子图，以便它们形成一个连贯的全局图。例如，此优化负责更改当前构建的轨迹，以根据循环闭合正确地对齐子图。整个算法过程大致如上。</p><p><img src="/.com//clip_image001.png" alt="img"></p><p>由各部分执行的功能和参数含义可知，我们通过调整TRAJECTORY_BUILDER_nD.max_range（25～30）来增加传感器传入的数据量，因为在Input Sensor Data中Cartographer通过bandpass filter，将数据的范围值保持在一定的最小和最大范围之间，同时对TRAJECTORY_BUILDER_nD.*adaptive_voxel_filter.max_length和TRAJECTORY_BUILDER_nD.*adaptive_voxel_filter.min_num_points也进行调整以适应传感器的值（前者3～4之间，后者150左右效果更好），对Local SLAM可接收的数据范围也要进行调整（例如TRAJECTORY_BUILDER_nD.submaps.num_range_data）。在LocalSLAM的建图过程中（通过预先将Global SLAM的优化关闭，POSE_GRAPH.optimize_every_n_nodes = 0），发现图中的旋转效果并不佳，因此，在CeresScanMatcher的优化过程中，增大TRAJECTORY_BUILDER_nD.ceres_scan_matcher.rotation_weight对优化此效果颇佳。</p><p><img src="/.com//image-20210608222319213.png" alt="image-20210608222319213"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大二下刚开学和shl一起参加了航天创意物流比赛，刚开始想着两个人去试试水，随便玩一下，后来开学没多久，因为一起参加比赛的另一支队伍缺员，于是两队考虑合并，至此之后就开始有点团队合作来学习了。整个比赛分为好几个部分，我主要负责一些路径规划的东西，因为大二上的时候学过数据结构，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaNote</title>
    <link href="http://example.com/2021/05/20/JavaNote/"/>
    <id>http://example.com/2021/05/20/JavaNote/</id>
    <published>2021-05-20T05:01:10.000Z</published>
    <updated>2021-06-21T00:41:37.033Z</updated>
    
    <content type="html"><![CDATA[<p>Q: </p><ol><li>this 的用法</li><li>抛出异常 throw.</li><li>learning how to write spec</li><li>搞清楚什么时候用lists, maps,queues,sets.</li><li>如何返回范型的imultable</li><li>强制转换。会不会改变地址。multable？</li></ol><p><strong>技术：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array.fill()方法：对一个数组进行填充:</span></span><br><span class="line"><span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[N * N + <span class="number">1</span>]; </span><br><span class="line">Arrays.fill(vis, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//public String trim()用于删除头尾空白符的字符串:</span></span><br><span class="line">String Str = <span class="keyword">new</span> String(<span class="string">&quot;    yrs    &quot;</span>);</span><br><span class="line">Str.trim();</span><br><span class="line"></span><br><span class="line"><span class="comment">//input : yrs</span></span><br><span class="line"><span class="comment">//output : yrs </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接抛出异常～</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;implement me!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Math 数学处理库，其中有abs,atan,PI...</span></span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line">Math.abs();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//assert : </span></span><br><span class="line"> <span class="keyword">assert</span> flag; <span class="comment">// 判断flag 是否为真</span></span><br><span class="line"> <span class="keyword">assert</span> string != <span class="keyword">null</span> : <span class="string">&quot;string is null&quot;</span> <span class="comment">// 如果string 是null则抛出带有说明的异常。</span></span><br></pre></td></tr></table></figure><p>super 可以用来引用直接父类的实例变量。 super 可以用来调用直接父类方法。 super () 可以用于调用直接父类构造函数。 可以使用 super 关键字来访问父类的数据成员或字段。 如果父类和子类具有相同的字段，则使用 super 来指定为父类数据成员或字段。</p><p>线性表list<a href="https://www.w3cschool.cn/java/java-list.html">see</a> :注意一下NullPointerException，不能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Double&gt; <span class="title">calculateBearings</span><span class="params">(List&lt;Integer&gt; xCoords, List&lt;Integer&gt; yCoords)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  List&lt;Double&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>屏幕的打印和输和print 的区别</strong><a href="(https://blog.csdn.net/baidu_41666198/article/details/79942661)">see</a> </p><p>正则表达式的使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">String R = <span class="string">&quot;([1-9]+(|\\.5)|(0\\.5))&quot;</span>;</span><br><span class="line">String I1 = <span class="string">&quot;1.5&quot;</span>;</span><br><span class="line">String I2 = <span class="string">&quot;0.5&quot;</span>;</span><br><span class="line">String I3 = <span class="string">&quot;1.52&quot;</span>;</span><br><span class="line">String I4 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">String I5 = <span class="string">&quot;.5&quot;</span>;</span><br><span class="line">String I6 = <span class="string">&quot;9.5&quot;</span>;</span><br><span class="line">String I7 = <span class="string">&quot;123.5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(&quot;String&quot;.matches(rel)); well done</span></span><br><span class="line">System.out.println(Pattern.matches(R,I1));<span class="comment">//T</span></span><br><span class="line">System.out.println(Pattern.matches(R,I2));<span class="comment">//T</span></span><br><span class="line">System.out.println(Pattern.matches(R,I3));<span class="comment">//F</span></span><br><span class="line">System.out.println(Pattern.matches(R,I4));<span class="comment">//T</span></span><br><span class="line">System.out.println(Pattern.matches(R,I5));<span class="comment">//F</span></span><br><span class="line">System.out.println(Pattern.matches(R,I6));<span class="comment">//T</span></span><br><span class="line">System.out.println(Pattern.matches(R,I7));<span class="comment">//T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A ::= </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note String.split() 应该处理正则表达式的特殊字符，比如：</span></span><br><span class="line"><span class="comment">// right :</span></span><br><span class="line">String[] names = value.split(<span class="string">&quot;//.&quot;</span>);</span><br><span class="line"><span class="comment">// error :</span></span><br><span class="line">String[] names = value.split(<span class="string">&quot;.&quot;</span>);</span><br></pre></td></tr></table></figure><p>Map 的用法<a href="https://www.runoob.com/java/java-map-interface.html">see</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure><p>打印数组：<a href="https://blog.csdn.net/lilong117194/article/details/83716244">打印二维数组</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] l = <span class="keyword">new</span> String[N];</span><br><span class="line">System.out.println(Arrays.toString(l));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不能使用：不同于C. java判断temp&lt;0之后还是会执行appear[temp].</span></span><br><span class="line">temp &lt; <span class="number">0</span> &amp;&amp; appear[temp] </span><br></pre></td></tr></table></figure><p><strong>概念：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Java 中一般使用 new 来创建对象，它可以动态地为一个对象分配地址。它的通用格式如下：</span></span><br><span class="line">classname obj = <span class="keyword">new</span> classname( );</span><br><span class="line"><span class="comment">//其中，obj 是创建的对象，classname 是类的名字，类名后边的( )指明了类的构造方法。</span></span><br><span class="line"><span class="comment">//构造方法定义了当创建一个对象时要进行的操作。</span></span><br><span class="line"><span class="comment">//e.g 类名称 对象名称 = new 类名称 () -&gt; 引用类型 对象名称 = new 新建对象的名字&lt;确定范型&gt;(调用构造方法的参数)；</span></span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;word&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个.java中一般是可以放多个类的，但是只能有一个用public修饰的类，</span></span><br><span class="line"><span class="comment">//并且public 修饰的class 的名字需要和java文件的名字相同（区分大小写）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>抽象类</strong><a href="https://www.runoob.com/java/java-abstraction.html">see</a> ： </p><p>​        其中有一个：构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ManWorker implements Workable, Feedable&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;...&#125;;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用范型来支持不同类型的参数： Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是Obeject不能持有基本类型。</p><p><strong>public 和 static:</strong></p><p>​    通常，大多数方法都是public的,私有(private)方法只能被同一类中的其它方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public 可以被外部用户访问：</span></span><br><span class="line"><span class="keyword">int</span> i = a.i;</span><br></pre></td></tr></table></figure><p>用static关键字修饰的字段称为静态字段 n 静态字段对类的每个实例都是共享的</p><p>可以用final关键字修饰一个实例字段，这种字段在构造对象时必须初始化<br>n 用final修饰的实例字段将不能再修改</p><p>对于static方法来说，static方法可以被类名对象进行调用，也可以在类中被其他方法调用。而非static方法只能先创建对象之后才能被对象调用。</p><p><strong>Java接口</strong>:</p><p><strong>什么是Junit</strong></p><hr><p>JUnit is a simple framework to write repeatable tests. It is an instance of the xUnit architecture for unit testing frameworks.</p><hr><p>eclipse 配置Junit <a href="https://blog.csdn.net/gzn00417/article/details/104163696">see</a>.</p><p>Set继承于Collection接口，是一个不允许出现重复元素，并且无序的集合，主要有HashSet和TreeSet两大实现类。</p><p><strong>Set</strong> <a href="https://www.jianshu.com/p/b48c47a42916">Java集合–Set(基础)</a></p><p>Set继承于Collection接口，是一个不允许出现重复元素，并且无序的集合，主要有HashSet和TreeSet两大实现类。</p><p>在判断重复元素的时候，Set集合会调用hashCode()和equals()方法来实现。</p><p>​    <strong>Note</strong> : 在自定义ADT时，需要重写Object 的equals，并且， == 是判断引用的相等，equals 判断的是字符串是否相等。</p><p>HashSet是哈希表结构，主要利用HashMap的key来存储元素，计算插入元素的hashCode来获取元素在集合中的位置；</p><p>TreeSet是红黑树结构，每一个元素都是树中的一个节点，插入的元素都会进行排序；</p><p><a href="https://blog.csdn.net/coding_1994/article/details/80553554">HashSet和TreeSet的区别_</a> </p><p><a href="https://blog.csdn.net/the_fool_/article/details/82389351">Set排序四种写法</a></p><hr><p>A <strong>concrete class</strong> is a class that has an implementation for all of its methods. They cannot have any unimplemented methods. It can also extend an <a href="https://www.geeksforgeeks.org/abstract-classes-in-java/">abstract class</a> or implement an <a href="https://www.geeksforgeeks.org/interfaces-in-java/">interface</a> as long as it implements all their methods. It is a complete class and can be instantiated.</p><hr><p><strong>new</strong>的含义和不同对象之间的比较问题:<a href="http://c.biancheng.net/view/6016.html">see</a>，同时涉及到multable与immultable.</p><p><a href="https://blog.csdn.net/qq_25077777/article/details/80174763">java中的null类型及注意事项</a></p><p><strong>Other refference:</strong></p><p>1.凸包问题： 给定平面上一堆点集，输出位于凸包上的点。</p><p>gift-wrapping algorithm.</p><p>Graham_Scan algorithm.</p><p>2.</p><hr><p>eclipse创建多工程的时候出现<a href="https://blog.csdn.net/jishu_vip/article/details/2617188?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">The input type of the launch configuration does not exist</a></p><p>两种类 ，</p><p>Graph&lt;String&gt; s tring范型.</p><p>代码覆盖度。AF RI</p><p>表暴露</p><p>参考网站与书籍：</p><ol><li>java核心技术</li><li><a href="https://www.liaoxuefeng.com/">廖雪峰的官方网站</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Q: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;this 的用法&lt;/li&gt;
&lt;li&gt;抛出异常 throw.&lt;/li&gt;
&lt;li&gt;learning how to write spec&lt;/li&gt;
&lt;li&gt;搞清楚什么时候用lists, maps,queues,sets.&lt;/li&gt;
&lt;li&gt;如何返</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Teach Me How to hexo</title>
    <link href="http://example.com/2021/05/17/hello-world/"/>
    <id>http://example.com/2021/05/17/hello-world/</id>
    <published>2021-05-17T08:28:00.684Z</published>
    <updated>2021-06-16T05:30:58.610Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Address-some-problem"><a href="#Address-some-problem" class="headerlink" title="Address some problem"></a>Address some problem</h3><p>安装plugin需要在~下安装，例如：(base) yrs@rongshuijiebadeMacBook-Pro ~ % npm install hexo-renderer-marked/</p><h3 id="Insert-pictures-into-posts"><a href="#Insert-pictures-into-posts" class="headerlink" title="Insert pictures into posts."></a>Insert pictures into posts.</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
