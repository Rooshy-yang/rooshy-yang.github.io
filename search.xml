<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaNote</title>
    <url>/2021/05/20/JavaNote/</url>
    <content><![CDATA[<p>Q: </p>
<ol>
<li>this 的用法</li>
<li>抛出异常 throw.</li>
<li>learning how to write spec</li>
<li>搞清楚什么时候用lists, maps,queues,sets.</li>
<li>如何返回范型的imultable</li>
<li>强制转换。会不会改变地址。multable？</li>
<li>父类 x = new 子类 和子类 x = new 父类。 接口定义</li>
<li>函数传参改变值的问题。有待验证：<a href="https://blog.csdn.net/sinat_22013331/article/details/51150358">(11条消息) 在java方法中改变传递的参数的值_Maxwell_7-CSDN博客</a></li>
<li>Rep Invariant.</li>
<li>Snapshot diagrams</li>
<li>编译时检查和运行时检查。instanceof 动态类型</li>
<li></li>
</ol>
<p><strong>技术：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Array.fill()方法：对一个数组进行填充:</span></span><br><span class="line"><span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[N * N + <span class="number">1</span>]; </span><br><span class="line">Arrays.fill(vis, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//public String trim()用于删除头尾空白符的字符串:</span></span><br><span class="line">String Str = <span class="keyword">new</span> String(<span class="string">&quot;    yrs    &quot;</span>);</span><br><span class="line">Str.trim();</span><br><span class="line"></span><br><span class="line"><span class="comment">//input : 	yrs		</span></span><br><span class="line"><span class="comment">//output : yrs </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接抛出异常～</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;implement me!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Math 数学处理库，其中有abs,atan,PI...</span></span><br><span class="line"><span class="keyword">import</span> java.lang.Math;</span><br><span class="line">Math.abs();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//assert : </span></span><br><span class="line"> <span class="keyword">assert</span> flag; <span class="comment">// 判断flag 是否为真</span></span><br><span class="line"> <span class="keyword">assert</span> string != <span class="keyword">null</span> : <span class="string">&quot;string is null&quot;</span> <span class="comment">// 如果string 是null则抛出带有说明的异常。</span></span><br></pre></td></tr></table></figure>

<p>super 可以用来引用直接父类的实例变量。 super 可以用来调用直接父类方法。 super () 可以用于调用直接父类构造函数。 可以使用 super 关键字来访问父类的数据成员或字段。 如果父类和子类具有相同的字段，则使用 super 来指定为父类数据成员或字段。</p>
<p>线性表list<a href="https://www.w3cschool.cn/java/java-list.html">see</a> :注意一下NullPointerException，不能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Double&gt; <span class="title">calculateBearings</span><span class="params">(List&lt;Integer&gt; xCoords, List&lt;Integer&gt; yCoords)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  List&lt;Double&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>屏幕的打印和输和print 的区别</strong><a href="(https://blog.csdn.net/baidu_41666198/article/details/79942661)">see</a> </p>
<p>正则表达式的使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		String R = <span class="string">&quot;([1-9]+(|\\.5)|(0\\.5))&quot;</span>;</span><br><span class="line">		String I1 = <span class="string">&quot;1.5&quot;</span>;</span><br><span class="line">		String I2 = <span class="string">&quot;0.5&quot;</span>;</span><br><span class="line">		String I3 = <span class="string">&quot;1.52&quot;</span>;</span><br><span class="line">		String I4 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">		String I5 = <span class="string">&quot;.5&quot;</span>;</span><br><span class="line">		String I6 = <span class="string">&quot;9.5&quot;</span>;</span><br><span class="line">		String I7 = <span class="string">&quot;123.5&quot;</span>;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		System.out.println(&quot;String&quot;.matches(rel)); well done</span></span><br><span class="line">		System.out.println(Pattern.matches(R,I1));<span class="comment">//T</span></span><br><span class="line">		System.out.println(Pattern.matches(R,I2));<span class="comment">//T</span></span><br><span class="line">		System.out.println(Pattern.matches(R,I3));<span class="comment">//F</span></span><br><span class="line">		System.out.println(Pattern.matches(R,I4));<span class="comment">//T</span></span><br><span class="line">		System.out.println(Pattern.matches(R,I5));<span class="comment">//F</span></span><br><span class="line">		System.out.println(Pattern.matches(R,I6));<span class="comment">//T</span></span><br><span class="line">		System.out.println(Pattern.matches(R,I7));<span class="comment">//T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	A ::= </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note String.split() 应该处理正则表达式的特殊字符，比如：</span></span><br><span class="line"><span class="comment">// right :</span></span><br><span class="line">String[] names = value.split(<span class="string">&quot;//.&quot;</span>);</span><br><span class="line"><span class="comment">// error :</span></span><br><span class="line">String[] names = value.split(<span class="string">&quot;.&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>Map 的用法<a href="https://www.runoob.com/java/java-map-interface.html">see</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map m = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure>



<p>打印数组：<a href="https://blog.csdn.net/lilong117194/article/details/83716244">打印二维数组</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] l = <span class="keyword">new</span> String[N];</span><br><span class="line">System.out.println(Arrays.toString(l));</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不能使用：不同于C. java判断temp&lt;0之后还是会执行appear[temp].</span></span><br><span class="line">temp &lt; <span class="number">0</span> &amp;&amp; appear[temp] </span><br></pre></td></tr></table></figure>



<p><strong>概念：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Java 中一般使用 new 来创建对象，它可以动态地为一个对象分配地址。它的通用格式如下：</span></span><br><span class="line">classname obj = <span class="keyword">new</span> classname( );</span><br><span class="line"><span class="comment">//其中，obj 是创建的对象，classname 是类的名字，类名后边的( )指明了类的构造方法。</span></span><br><span class="line"><span class="comment">//构造方法定义了当创建一个对象时要进行的操作。</span></span><br><span class="line"><span class="comment">//e.g 类名称 对象名称 = new 类名称 () -&gt; 引用类型 对象名称 = new 新建对象的名字&lt;确定范型&gt;(调用构造方法的参数)；</span></span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">&quot;word&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个.java中一般是可以放多个类的，但是只能有一个用public修饰的类，</span></span><br><span class="line"><span class="comment">//并且public 修饰的class 的名字需要和java文件的名字相同（区分大小写）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>抽象类</strong><a href="https://www.runoob.com/java/java-abstraction.html">see</a> ： </p>
<p>​        其中有一个：构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p>
<p>一个类只能继承一个抽象类，而一个类却可以实现多个接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ManWorker implements Workable, Feedable&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;...&#125;;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>使用范型来支持不同类型的参数： Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是Obeject不能持有基本类型。</p>
<p><strong>public 和 static:</strong></p>
<p>​    通常，大多数方法都是public的,私有(private)方法只能被同一类中的其它方法调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public 可以被外部用户访问：</span></span><br><span class="line"><span class="keyword">int</span> i = a.i;</span><br></pre></td></tr></table></figure>

<p>用static关键字修饰的字段称为静态字段 n 静态字段对类的每个实例都是共享的</p>
<p>可以用final关键字修饰一个实例字段，这种字段在构造对象时必须初始化<br>n 用final修饰的实例字段将不能再修改</p>
<p>对于static方法来说，static方法可以被类名对象进行调用，也可以在类中被其他方法调用。而非static方法只能先创建对象之后才能被对象调用。</p>
<p><strong>Java接口</strong>:</p>
<p><strong>什么是Junit</strong></p>
<hr>
<p>JUnit is a simple framework to write repeatable tests. It is an instance of the xUnit architecture for unit testing frameworks.</p>
<hr>
<p>eclipse 配置Junit <a href="https://blog.csdn.net/gzn00417/article/details/104163696">see</a>.</p>
<p>Set继承于Collection接口，是一个不允许出现重复元素，并且无序的集合，主要有HashSet和TreeSet两大实现类。</p>
<p><strong>Set</strong> <a href="https://www.jianshu.com/p/b48c47a42916">Java集合–Set(基础)</a></p>
<p>Set继承于Collection接口，是一个不允许出现重复元素，并且无序的集合，主要有HashSet和TreeSet两大实现类。</p>
<p>在判断重复元素的时候，Set集合会调用hashCode()和equals()方法来实现。</p>
<p>​    <strong>Note</strong> : 在自定义ADT时，需要重写Object 的equals，并且， == 是判断引用的相等，equals 判断的是字符串是否相等。</p>
<p>HashSet是哈希表结构，主要利用HashMap的key来存储元素，计算插入元素的hashCode来获取元素在集合中的位置；</p>
<p>TreeSet是红黑树结构，每一个元素都是树中的一个节点，插入的元素都会进行排序；</p>
<p><a href="https://blog.csdn.net/coding_1994/article/details/80553554">HashSet和TreeSet的区别_</a> </p>
<p><a href="https://blog.csdn.net/the_fool_/article/details/82389351">Set排序四种写法</a></p>
<hr>
<p>A <strong>concrete class</strong> is a class that has an implementation for all of its methods. They cannot have any unimplemented methods. It can also extend an <a href="https://www.geeksforgeeks.org/abstract-classes-in-java/">abstract class</a> or implement an <a href="https://www.geeksforgeeks.org/interfaces-in-java/">interface</a> as long as it implements all their methods. It is a complete class and can be instantiated.</p>
<hr>
<p><strong>new</strong>的含义和不同对象之间的比较问题:<a href="http://c.biancheng.net/view/6016.html">see</a>，同时涉及到multable与immultable.</p>
<p><a href="https://blog.csdn.net/qq_25077777/article/details/80174763">java中的null类型及注意事项</a></p>
<p><strong>Other refference:</strong></p>
<p>1.凸包问题： 给定平面上一堆点集，输出位于凸包上的点。</p>
<p>gift-wrapping algorithm.</p>
<p>Graham_Scan algorithm.</p>
<p>2.</p>
<hr>
<p>eclipse创建多工程的时候出现<a href="https://blog.csdn.net/jishu_vip/article/details/2617188?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">The input type of the launch configuration does not exist</a></p>
<p>两种类 ，</p>
<p>Graph&lt;String&gt; s tring范型.</p>
<p>代码覆盖度。AF RI</p>
<p>表暴露</p>
<p>参考网站与书籍：</p>
<ol>
<li>java核心技术</li>
<li><a href="https://www.liaoxuefeng.com/">廖雪峰的官方网站</a></li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Teach Me How to hexo</title>
    <url>/2021/05/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="Address-some-problem"><a href="#Address-some-problem" class="headerlink" title="Address some problem"></a>Address some problem</h3><p>安装plugin需要在~下安装，例如：(base) yrs@rongshuijiebadeMacBook-Pro ~ % npm install hexo-renderer-marked/</p>
<h3 id="Insert-pictures-into-posts"><a href="#Insert-pictures-into-posts" class="headerlink" title="Insert pictures into posts."></a>Insert pictures into posts.</h3>]]></content>
  </entry>
  <entry>
    <title>深入理解计算机系统笔记</title>
    <url>/2021/06/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image001-4971512.jpg" alt="img"></p>
<p><strong>摘 要</strong></p>
<p>​    本文主要阐述并分析了Hello World从C语言生成到程序运行结束过程中的一系列过程。包括编译器下预处理，编译，汇编，链接各个过程中Hello World的变化；分析了计算机如何管理进程，Shell如何使Hello World得以加载到内存中执行；计算机的内存管理系统如何高效地对Hello World的地址进行管理；并从万物皆文件的角度来观察Hello World。</p>
<p><strong>关键词：</strong>C语言，预处理，编译，链接，进程，MMU，文件，内存，CPU，Shell.           </p>
<p><strong>目 录</strong></p>
<p><a href="#_Toc532238396">第1章 概述…………………………………………………………………………………………………. - 4 -</a></p>
<p><a href="#_Toc532238397">1.1 Hello简介…………………………………………………………………………………………… - 4 -</a></p>
<p><a href="#_Toc532238398">1.2 环境与工具………………………………………………………………………………………….. - 4 -</a></p>
<p><a href="#_Toc532238399">1.3 中间结果……………………………………………………………………………………………… - 4 -</a></p>
<p><a href="#_Toc532238400">1.4 本章小结……………………………………………………………………………………………… - 4 -</a></p>
<p><a href="#_Toc532238401">第2章 预处理……………………………………………………………………………………………… - 5 -</a></p>
<p><a href="#_Toc532238402">2.1 预处理的概念与作用……………………………………………………………………………. - 5 -</a></p>
<p><a href="#_Toc532238403">2.2在Ubuntu下预处理的命令………………………………………………………………….. - 5 -</a></p>
<p><a href="#_Toc532238404">2.3 Hello的预处理结果解析……………………………………………………………………… - 5 -</a></p>
<p><a href="#_Toc532238405">2.4 本章小结……………………………………………………………………………………………… - 5 -</a></p>
<p><a href="#_Toc532238406">第3章 编译…………………………………………………………………………………………………. - 6 -</a></p>
<p><a href="#_Toc532238407">3.1 编译的概念与作用……………………………………………………………………………….. - 6 -</a></p>
<p><a href="#_Toc532238408">3.2 在Ubuntu下编译的命令…………………………………………………………………….. - 6 -</a></p>
<p><a href="#_Toc532238409">3.3 Hello的编译结果解析…………………………………………………………………………. - 6 -</a></p>
<p><a href="#_Toc532238410">3.4 本章小结……………………………………………………………………………………………… - 6 -</a></p>
<p><a href="#_Toc532238411">第4章 汇编…………………………………………………………………………………………………. - 7 -</a></p>
<p><a href="#_Toc532238412">4.1 汇编的概念与作用……………………………………………………………………………….. - 7 -</a></p>
<p><a href="#_Toc532238413">4.2 在Ubuntu下汇编的命令…………………………………………………………………….. - 7 -</a></p>
<p><a href="#_Toc532238414">4.3 可重定位目标elf格式………………………………………………………………………… - 7 -</a></p>
<p><a href="#_Toc532238415">4.4 Hello.o的结果解析…………………………………………………………………………….. - 7 -</a></p>
<p><a href="#_Toc532238416">4.5 本章小结……………………………………………………………………………………………… - 7 -</a></p>
<p><a href="#_Toc532238417">第5章 链接…………………………………………………………………………………………………. - 8 -</a></p>
<p><a href="#_Toc532238418">5.1 链接的概念与作用……………………………………………………………………………….. - 8 -</a></p>
<p><a href="#_Toc532238419">5.2 在Ubuntu下链接的命令…………………………………………………………………….. - 8 -</a></p>
<p><a href="#_Toc532238420">5.3 可执行目标文件hello的格式……………………………………………………………… - 8 -</a></p>
<p><a href="#_Toc532238421">5.4 hello的虚拟地址空间…………………………………………………………………………. - 8 -</a></p>
<p><a href="#_Toc532238422">5.5 链接的重定位过程分析………………………………………………………………………… - 8 -</a></p>
<p><a href="#_Toc532238423">5.6 hello的执行流程………………………………………………………………………………… - 8 -</a></p>
<p><a href="#_Toc532238424">5.7 Hello的动态链接分析…………………………………………………………………………. - 8 -</a></p>
<p><a href="#_Toc532238425">5.8 本章小结……………………………………………………………………………………………… - 9 -</a></p>
<p><a href="#_Toc532238426">第6章 hello进程管理…………………………………………………………………………… - 10 -</a></p>
<p><a href="#_Toc532238427">6.1 进程的概念与作用……………………………………………………………………………… - 10 -</a></p>
<p><a href="#_Toc532238428">6.2 简述壳Shell-bash的作用与处理流程……………………………………………….. - 10 -</a></p>
<p><a href="#_Toc532238429">6.3 Hello的fork进程创建过程………………………………………………………………. - 10 -</a></p>
<p><a href="#_Toc532238430">6.4 Hello的execve过程…………………………………………………………………………. - 10 -</a></p>
<p><a href="#_Toc532238431">6.5 Hello的进程执行………………………………………………………………………………. - 10 -</a></p>
<p><a href="#_Toc532238432">6.6 hello的异常与信号处理……………………………………………………………………. - 10 -</a></p>
<p><a href="#_Toc532238433">6.7本章小结……………………………………………………………………………………………. - 10 -</a></p>
<p><a href="#_Toc532238434">第7章 hello的存储管理……………………………………………………………………….. - 11 -</a></p>
<p><a href="#_Toc532238435">7.1 hello的存储器地址空间……………………………………………………………………. - 11 -</a></p>
<p><a href="#_Toc532238436">7.2 Intel逻辑地址到线性地址的变换-段式管理……………………………………….. - 11 -</a></p>
<p><a href="#_Toc532238437">7.3 Hello的线性地址到物理地址的变换-页式管理………………………………….. - 11 -</a></p>
<p><a href="#_Toc532238438">7.4 TLB与四级页表支持下的VA到PA的变换………………………………………… - 11 -</a></p>
<p><a href="#_Toc532238439">7.5 三级Cache支持下的物理内存访问……………………………………………………. - 11 -</a></p>
<p><a href="#_Toc532238440">7.6 hello进程fork时的内存映射…………………………………………………………… - 11 -</a></p>
<p><a href="#_Toc532238441">7.7 hello进程execve时的内存映射……………………………………………………….. - 11 -</a></p>
<p><a href="#_Toc532238442">7.8 缺页故障与缺页中断处理…………………………………………………………………… - 11 -</a></p>
<p><a href="#_Toc532238443">7.9动态存储分配管理……………………………………………………………………………… - 11 -</a></p>
<p><a href="#_Toc532238444">7.10本章小结………………………………………………………………………………………….. - 12 -</a></p>
<p><a href="#_Toc532238445">第8章 hello的IO管理………………………………………………………………………… - 13 -</a></p>
<p><a href="#_Toc532238446">8.1 Linux的IO设备管理方法………………………………………………………………….. - 13 -</a></p>
<p><a href="#_Toc532238447">8.2 简述Unix IO接口及其函数……………………………………………………………….. - 13 -</a></p>
<p><a href="#_Toc532238448">8.3 printf的实现分析………………………………………………………………………………. - 13 -</a></p>
<p><a href="#_Toc532238449">8.4 getchar的实现分析…………………………………………………………………………… - 13 -</a></p>
<p><a href="#_Toc532238450">8.5本章小结……………………………………………………………………………………………. - 13 -</a></p>
<p><a href="#_Toc532238451">结论……………………………………………………………………………………………………………. - 14 -</a></p>
<p><a href="#_Toc532238452">附件……………………………………………………………………………………………………………. - 15 -</a></p>
<p><a href="#_Toc532238453">参考文献…………………………………………………………………………………………………….. - 16 -</a></p>
<h1 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h1><h2 id="1-1-Hello简介"><a href="#1-1-Hello简介" class="headerlink" title="1.1 Hello简介"></a>1.1 Hello简介</h2><p>Hello P2P : 对一个HelloWorld而言，首先先从Hello.c文件，通过预处理、编译、汇编、链接等一系列过程生成可执行文件，得到P（即Process），各类Shell命令处理器调用Fork，生成一个子进程再调用execve系统函数，将HelloWorld加载到内存中执行, 最终在屏幕打印HelloWorld，结束进程。</p>
<p>Hello 020 : Hello可执行文件加载到内存，CPU生成各类数据结构来维护程序的运行，这是从0到有。程序运行结束之后，父进程回收子进程，内核删除相关的数据结构，释放堆栈等一系列子进程有关的空间，这是从有到无。</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image002-4971512.png" alt="img"></p>
<h2 id="1-2-环境与工具"><a href="#1-2-环境与工具" class="headerlink" title="1.2 环境与工具"></a>1.2 环境与工具</h2><p>​    环境：</p>
<p>​    1.4 GHz Quad-Core Intel Core i5 Processor</p>
<p>​    8 GB 2133 MHz LPDDR3 Memory</p>
<p>​    Intel Iris Plus Graphics 645 1536 MB Graphics</p>
<p>​    macOS Big Sur Version 11.2.3,Virtual box ubuntu 16.04</p>
<p>工具 ： GDB调试， GCC，Readelf,  Valgrind。</p>
<h2 id="1-3-中间结果"><a href="#1-3-中间结果" class="headerlink" title="1.3 中间结果"></a>1.3 中间结果</h2><p>hello.i 预处理之后的文本文件。</p>
<p>hello.s 汇编后的文本文件。</p>
<p>hello.o 可重定位文件hello.o。</p>
<p>hello 从hello.o链接而成的可执行目标文件。</p>
<p>Oelf.d 由可重定位目标文件hello.o生成的elf文件。</p>
<p>Aelf.txt 由可执行目标文件hello生成的elf文件。</p>
<p>Oobj 由可重定位目标文件hello.o反汇编得到的文件。</p>
<p>Aobj 由可执行目标文件hello反汇编得到的文件。</p>
<h2 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h2><p>Hello的产生这一系列的过程是所有的程序的必经之路，包括编译器的努力，内存的分配，CPU的工作等。下面来依依讲解这些内容。</p>
<h1 id="第2章-预处理"><a href="#第2章-预处理" class="headerlink" title="第2章 预处理"></a>第2章 预处理</h1><h2 id="2-1-预处理的概念与作用"><a href="#2-1-预处理的概念与作用" class="headerlink" title="2.1 预处理的概念与作用"></a>2.1 预处理的概念与作用</h2><p>C预处理器（C Pre-Processor）也常简写为 CPP，是一个与 C 编译器独立的小程序，在程序源代码被翻译为目标代码的过程中，生成二进制代码之前的过程， C语言的预处理主要有三个方面的内容： 宏定义 、文件包含、条件编译。预处理命令以符号“#”开头，预处理器可以得到.i文件。</p>
<p>预处理作用：C预处理器扩展源代码，插入所有用#include命令指定的文件，并扩展所有用#define声明指定的宏；有选择性地执行相应操作(如ifdef)，防止宏替换内容（如文件等）的重复包含; 定义宏 #define 和宏删除 #undef。</p>
<h2 id="2-2在Ubuntu下预处理的命令"><a href="#2-2在Ubuntu下预处理的命令" class="headerlink" title="2.2在Ubuntu下预处理的命令"></a>2.2在Ubuntu下预处理的命令</h2><p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image003-4971512.png" alt="img"></p>
<h2 id="2-3-Hello的预处理结果解析"><a href="#2-3-Hello的预处理结果解析" class="headerlink" title="2.3 Hello的预处理结果解析"></a>2.3 Hello的预处理结果解析</h2><p>include &lt;stdio.h&gt;等三个头文件消失，替代的是一大段代码，描述的是运行库在计算机中的位置，main函数的内容基本不变，方便下一步翻译成汇编语言。</p>
<h2 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h2><p>预处理是程序运行中不可缺少的步骤，只有通过预处理之后的文件才能被编译器进行。该章阐述了预处理的概念和作用。</p>
<h1 id="第3章-编译"><a href="#第3章-编译" class="headerlink" title="第3章 编译"></a>第3章 编译</h1><h2 id="3-1-编译的概念与作用"><a href="#3-1-编译的概念与作用" class="headerlink" title="3.1 编译的概念与作用"></a>3.1 编译的概念与作用</h2><p>编译器 (ccl)可以将文本文件hello.i 翻译成文本文件hello.s, .s包含一个汇编语言程序，可以把用高级程序设计语言书写的源程序，翻译成更底层的机器语言的目标程序。</p>
<h2 id="3-2-在Ubuntu下编译的命令"><a href="#3-2-在Ubuntu下编译的命令" class="headerlink" title="3.2 在Ubuntu下编译的命令"></a>3.2 在Ubuntu下编译的命令</h2><p>gcc -S hello.c -o hello.s</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image004-4971512.png" alt="img"></p>
<h2 id="3-3-Hello的编译结果解析"><a href="#3-3-Hello的编译结果解析" class="headerlink" title="3.3 Hello的编译结果解析"></a>3.3 Hello的编译结果解析</h2><p><strong>下面分析对各种C数据类型和运算与汇编语言的对应关系：</strong></p>
<p>3.3.1. 常量：常量包括字符串，整型，浮点型常量，编译器将常量存储在.rodata中，通过相对地址寻址获取值。<br> <img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image005-4971512.png" alt="img"></p>
<p>3.3.2  变量与赋初值/不赋初值: 初始化的全局变量和静态变量保存在.data段，局部变量保存在堆栈段，未初始化的全局变量和静态变量存在.bss和.COM，各种运算的操作是通过寻址来获取相应的值。</p>
<p>3.3.3 表达式和赋值=： 常量直接运算，如果是变量求值则配合add , sub , inc, leaq ，movslq(转换)等操作完成，浮点数使用%yumm相关寄存器。</p>
<p>3.3.4 类型： 编译器识别不同类型的数据选择不同的机器指令来执行。</p>
<p>3.3.5 宏： 编译器会消除宏定义</p>
<p>3.3.6 逗号操作符: 在变量声明语句、函数调用中，逗号是做分隔符用的，逗号连接表达式：<img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image006-4971512.png" alt="img"></p>
<p>得到：<img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image007-4971512.png" alt="img"></p>
<p>3.3.7类型转换(隐式或显式) ： 隐式类型转换的规则：signed会转换为unsigned，若运算数中有double型或float型，则其他类型数据均转换成double类型进行运算。若运算数中最长的类型为long型．则其他类型数均转换成long型数。若运算数中最长类型为int型，则char型也转换成int型进行运算。显式转换由程序员定义。</p>
<p>3.3.8: Sizeof， 返回一个unsigned int 类型的值，表示该变量的大小，编译器直接计算出这个值当作常量。</p>
<p>3.3.9: + - * / % ++ – 取正/负+- 复合“+=”分别对应add , sub , imul/mul , div/ div , dec , inc, 复合+= 目的地址是原地址，例如 leaq 5(%rax) , %rax;</p>
<p>3.3.10:逻辑&amp;&amp; || ! 编译器会进行多次比较来进行操作，例如：<img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image008-4971512.png" alt="img">编译器翻译成：<img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image009-4971512.png" alt="img"></p>
<p>3.3.11 位 &amp; | ~ ^  ： 编译器使用 and , or, not, xor 。</p>
<p>3.3.12移位&gt;&gt;  &lt;&lt;  编译器使用SAL，SHL,SAR, SHR.</p>
<p>3.3.13复合操作如 “|=” 或“&lt;&lt;=”等,和| &lt;&lt; 一样，只是目的地址是左边的符号的地址。</p>
<p>3.3.14数组/指针/结构操作：A[i]  &amp;v  *p   s.id  p-&gt;id</p>
<p>编译器使用M[ imm * R[] + R[]]l来访问数组，指针的值，例如：movl L1.(, %rdi, 4) , %rax. 结构体和数组一样顺序存储，并且保持对齐原则。</p>
<p>3.3.15: 控制转移 : if/ else while, do, while 等控制语句通过comp 语句和相关jmp指令的配合使用进行跳转，例如：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image010-4971512.png" alt="img"></p>
<p>语句将-20(%rsp)地址的值和3进行比较，je如果等于就跳转到.L2处，否则执行34行的指令。</p>
<p>3.3.16 ： 函数调用和函数返回，参数传递(地址/值)。参数可以通过寄存器或栈帧进行传递，在函数调用的时候，参数会依次存在%rdi,%rsi,%rdx,%rcx, %r8,%r9中，如果大于6个参数，后面的参数用栈进行保存。函数调用的时候会在栈上开辟一段空间供函数使用，函数返回的时候恢复栈帧并将返回值赋给%rax。</p>
<h2 id="3-4-本章小结"><a href="#3-4-本章小结" class="headerlink" title="3.4 本章小结"></a>3.4 本章小结</h2><p>编译器将高级程序翻译成对应的汇编指令，为汇编器进一步翻译成二进制机器指令作铺垫。值得一提的是，编译器会提供各种不同的优化策略，例如O3，O2，Og优化使汇编代码变得更高效。</p>
<h1 id="第4章-汇编"><a href="#第4章-汇编" class="headerlink" title="第4章 汇编"></a>第4章 汇编</h1><h2 id="4-1-汇编的概念与作用"><a href="#4-1-汇编的概念与作用" class="headerlink" title="4.1 汇编的概念与作用"></a>4.1 汇编的概念与作用</h2><p>​    汇编器（as）将汇编语言书写的程序翻译成与之等价的机器指令的，汇编器把这些指令打包成可重定位目标程序的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它包含的是程序的指令编码。</p>
<h2 id="4-2-在Ubuntu下汇编的命令"><a href="#4-2-在Ubuntu下汇编的命令" class="headerlink" title="4.2 在Ubuntu下汇编的命令"></a>4.2 在Ubuntu下汇编的命令</h2><p>​    gcc -c hello.c -o hello. o .需要用readelf 来查看.o 文件</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image011-4971512.png" alt="img"></p>
<h2 id="4-3-可重定位目标elf格式"><a href="#4-3-可重定位目标elf格式" class="headerlink" title="4.3 可重定位目标elf格式"></a>4.3 可重定位目标elf格式</h2><p> 命令行下输入： readelf -a hello.o :</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image012-4971512.png" alt="img"></p>
<p>ELF头</p>
<p>首先显示的是ELF 头，描述了字节大小和顺序，ELF 头的大小，Type 是目标文件类型，机器类型Machine, 节头部表的偏移和大小，下面还有节头部表，他描述了每个节的大小，位置等信息：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image013-4971512.png" alt="img"></p>
<p>​    节头部表</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image014-4971512.png" alt="img"></p>
<p>symtab表</p>
<p>.text：已编译程序的机器代码,main函数的机器指令就在这里。</p>
<p>.rodata：只读数据，比如printf语句中的格式式串和开关语句的跳转表。</p>
<p>.data：已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在.data节中，也不出现在.bss节中。</p>
<p>.bss：未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0。</p>
<p>.symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息..symtab符号表不包含局部变量的条目。</p>
<p>.rel.text：一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。</p>
<p>.rel.data：被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。</p>
<h2 id="4-4-Hello-o的结果解析"><a href="#4-4-Hello-o的结果解析" class="headerlink" title="4.4 Hello.o的结果解析"></a>4.4 Hello.o的结果解析</h2><p>objdump -d -r hello.o hello.o的反汇编如下：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image015-4971512.png" alt="img"></p>
<p>hello.o的反汇编代码</p>
<p>与第3章的 hello.s相比，objdump反汇编得到的代码会有汇编代码于机器代码对应，例如48 89 c6 对应于 mov %rax ,%rsi 这个操作。在.s文件中，call调用函数后是一个函数名：Call puts@PLT; 而在反汇编中，5d行的call后是下一条指令的地址（虽然不是最终的地址，但是我们能知道寻址的方法，在可执行文件中我们才能知道最终地址是什么，后面我们会讲到），许多函数要从链接的库中调用，call将他们的相对地址全都设置为0，在.rela.text中设置重定位条目，链接之后得到在内存中的地址。</p>
<h2 id="4-5-本章小结"><a href="#4-5-本章小结" class="headerlink" title="4.5 本章小结"></a>4.5 本章小结</h2><p>汇编器将.s翻译成机器语言指令，结果保存在.o文件中，linux下可以通过readelf 来查看.o文件的内容，.o文件可以与其他目标文件一起链接成可执行文件。</p>
<h1 id="第5章-链接"><a href="#第5章-链接" class="headerlink" title="第5章 链接"></a>第5章 链接</h1><h2 id="5-1-链接的概念与作用"><a href="#5-1-链接的概念与作用" class="headerlink" title="5.1 链接的概念与作用"></a>5.1 链接的概念与作用</h2><p><strong>链接</strong>（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加载时（load time），也就是在程序被加载器（load-er）加载到内存并执行时；甚至执行于运行时（runtime），也就是由应用程序来执行。在现代系统中，链接是由叫做链接器（linker）的程序自动执行的。它能够将各种代码和数据片段收集并组合成为一个单一文件，最终被执行。链接的步骤分别为符号解析和重定位。</p>
<h2 id="5-2-在Ubuntu下链接的命令"><a href="#5-2-在Ubuntu下链接的命令" class="headerlink" title="5.2 在Ubuntu下链接的命令"></a>5.2 在Ubuntu下链接的命令</h2><p>使用：ld -o hello -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib/x86_64-linux-gnu/crt1.o /usr/lib/x86_64-linux-gnu/crti.o /usr/lib/x86_64-linux-gnu/libc.so /usr/lib/x86_64-linux-gnu/crtn.o <strong>hello.o</strong></p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image016-4971512.png" alt="img"></p>
<h2 id="5-3-可执行目标文件hello的格式"><a href="#5-3-可执行目标文件hello的格式" class="headerlink" title="5.3 可执行目标文件hello的格式"></a>5.3 可执行目标文件hello的格式</h2><p>简要分析hello的ELF格式，包括各段的起始地址，大小等信息。用指令readelf -a hello 查看文件信息，与.o的ELF 格式有所不同，可执行目标文件的格式为：</p>
<img src="/.com//content/深入理解计算机系统/clip_image017-4971512.png" alt="img" style="zoom:50%;">

<p>符号表，调试信息节头部表不包含在可执行文件中，而是增加了.init，.fini，.plt，.plt.got等节，分别是程序初始化执行的代码，程序终止时需要执行的代码，动态链接中的过程连接表，动态链接中的全局偏移表。</p>
<p>可执行文件的指令地址经过链接器的重定位之后被确定了下来，例如main函数：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image018-4971512.png" alt="img"></p>
<p>表明main函数的入口位置在0x4011b6处。</p>
<h2 id="5-4-hello的虚拟地址空间"><a href="#5-4-hello的虚拟地址空间" class="headerlink" title="5.4 hello的虚拟地址空间"></a>5.4 hello的虚拟地址空间</h2><p>  使用gdb加载hello, 在gdb 下运行layout asm 然后设置断点b main,查看main函数的地址：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image019-4971512.png" alt="img"></p>
<p>5.3的分析无误。</p>
<h2 id="5-5-链接的重定位过程分析"><a href="#5-5-链接的重定位过程分析" class="headerlink" title="5.5 链接的重定位过程分析"></a>5.5 链接的重定位过程分析</h2><p>现在要分析hello与hello.o的不同，使用objdump -d -r hello查看可执行文件的反汇编信息：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image020-4971512.png" alt="img"></p>
<p>可以看到，与之前.s 和.o文件不同的是4011d6行的指令Callq 有了合法的虚拟地址，而不是用0 或者单个函数来表示，说明链接之后的可执行文件可以直接载入到内存中。</p>
<p>静态链接的过程：为了完成链接任务，链接器必须完成两个主要任务，首先要先进行符号解析，将目标文件引用的符号和定义的符号关联起来，如果有静态链接库.a文件，则需要关联.o中引用的.a中的符号。如果是全局符号的情况，编译器会假设符号会在其他模块中定义，这时候会生成一些符号表条目让链接器来处理，链接器拿到多个.o文件的符号表，对每一个符号考虑强弱，优先关联强符号，不允许有同名的强符号，没有强符号任意选择一个弱符号。</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image021-4971512.png" alt="img"></p>
<p>接下来是<strong>重定位</strong>：</p>
<p>汇编器生成一个目标模块时，只解析符号的话是不知道数据和代码最终将放在内存中的什么位置的。也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中。已初始化数据的重定位条目放在.rel.data中。</p>
<p>下面结合hello.o的重定位项目，分析hello中对其怎么重定位的。</p>
<p>ELF 定义了32种不同的重定位类型，但目前接触到的方法主要是两种，一种是R_X86_64_PC32，即PC相对寻址：重定位一个使用32位PC相对地址的引用。它利用的是一个PC相对地址就是距程序计数器（PC）的当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，就将在指令中编码的32位值加上PC的当前运行时值，得到有效地址（如call指令的目标），PC值通常是下一条指令在内存中的地址。</p>
<p>R_X86_64_32，即绝对寻址：重定位一个使用32位绝对地址的引用。通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。</p>
<p><strong>1.重定位PC相对引用</strong></p>
<p><strong>refaddr=ADDR（s）+ r.offset;</strong></p>
<p>*<strong>refptr=(unsigned)(ADDR(r.symbol) + r.addend-refaddr</strong></p>
<p><strong>2.重定位PC绝对引用</strong></p>
<p>*<strong>refptr=(unsigned)(ADDR(r.symbol)+r.addend);</strong></p>
<p><strong>其中s是对应的节，r是符号对应的重定位条目。</strong></p>
<h2 id="5-6-hello的执行流程"><a href="#5-6-hello的执行流程" class="headerlink" title="5.6 hello的执行流程"></a>5.6 hello的执行流程</h2><p>使用GDB，说明从加载hello到_start，到call main,以及程序终止的所有过程。列出执行hello其调用与跳转的各个子程序名或程序地址。</p>
<p>Step1 :gdb 查看所有函数：</p>
<img src="/.com//content/深入理解计算机系统/clip_image022-4971512.png" alt="img" style="zoom: 50%;">

<p>Step2 ： 对每一个函数依次设置断点：</p>
<img src="/.com//content/深入理解计算机系统/clip_image023-4971512.png" alt="img" style="zoom:50%;">

<p>Step3 ：gdb 下输入layout asm 后 再输入r 运行程序：</p>
<img src="/.com//content/深入理解计算机系统/clip_image024-4971512.png" alt="img" style="zoom:50%;">

<p>0x00000000004010d0 in &lt;_start&gt;</p>
<p>0x7ffff7deafc0 &lt;_libc_start_main&gt;</p>
<p>0x0000000000401240 in __libc_csu_init ()</p>
<p>0x00000000004011b0 in frame_dummy ()</p>
<p>0x0000000000401140 in register_tm_clones ()</p>
<p>0x00000000004011b6 in main ()</p>
<p>0x7ffff7e4b5a0 &lt;__GI__IO_puts&gt;       // 打印字符串  </p>
<p>0x7ffff7e0dbc0 &lt;__GI_exit&gt;</p>
<p>0x0000000000401180 in __do_global_dtors_aux ()</p>
<p>0x0000000000401110 in deregister_tm_clones ()</p>
<p>0x00000000004012b8 in _fini ()</p>
<h2 id="5-7-Hello的动态链接分析"><a href="#5-7-Hello的动态链接分析" class="headerlink" title="5.7 Hello的动态链接分析"></a>5.7 Hello的动态链接分析</h2><p>下面分析hello程序的动态链接项目，通过gdb调试，分析在dl_init前后，这些项目的内容变化:</p>
<p>首先看动态链接的定义： 在运行或加载是，加载共享库到任意的内存地址，并和一个在内存中的程序链接起来的过程：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image025-4971512.png" alt="img"></p>
<p>​    在dl_init前， PIC函数调用的目标地址都实际指向PLT中的代码逻辑，初始时每个GOT条目都指向对应的PLT条目的第二条指令。</p>
<p>​    当某个动态链接函数第一次被调用，会先进入对应的PLT条目，然后PLT指令跳转到对应的GOT条目中，其内容是PLT的下一条指令。然后将函数的ID压入栈中后跳转到PLT[0]。PLT[0]通过GOT[1]将动态链接库的一个参数压入栈中，再通过GOT[2]间接跳转进动态链接器中。动态链接器使用两个栈条目来确定函数的运行时位置，用这个地址重写GOT[4]，然后再次调用函数。经过上述操作，再次调用时PLT[2]会直接跳转通过GOT[4]跳转到函数而不是PLT[2]的下一条地址，这就是GOT的运行机制，它很好地利用了地址相对位置不变机制来设计GOT。</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image026-4971512.png" alt="img"></p>
<p>dl_init运行前</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image027-4971512.png" alt="img"></p>
<p>dl_init运行后</p>
<h2 id="5-8-本章小结"><a href="#5-8-本章小结" class="headerlink" title="5.8 本章小结"></a>5.8 本章小结</h2><p>分析hello.o进行链接得到了可执行目标文件hello，分析hello的ELF格式，观察动态链接中dl_init 前后GOT值的变化，可以看出将各种代码和数据片段收集并组合成为一个单一文件确实是一个复杂的过程。<br> <strong>第6章 hello进程管理</strong></p>
<h2 id="6-1-进程的概念与作用"><a href="#6-1-进程的概念与作用" class="headerlink" title="6.1 进程的概念与作用"></a>6.1 进程的概念与作用</h2><p>进程是一个执行中程序的实例，是程序及其数据在CPU下顺序执行时所发生的活动，进程是具有独立功能的程序在数据集上运行的过程，它是系统进行资源分配和调度的一个独立单位。它可以使CPU并行完成任务，并高效利用内存和CPU。</p>
<h2 id="6-2-简述壳Shell-bash的作用与处理流程"><a href="#6-2-简述壳Shell-bash的作用与处理流程" class="headerlink" title="6.2 简述壳Shell-bash的作用与处理流程"></a>6.2 简述壳Shell-bash的作用与处理流程</h2><p>Linux系统中，Shell是一个交互型应用级程序，代表用户运行其他程序(是命令行解释器，以用户态方式运行的终端进程)。</p>
<p>其基本功能是解释并运行用户的指令，重复如下处理过程： </p>
<p>(1)终端进程读取用户由键盘输入的命令行。 </p>
<p>(2)分析命令行字符串，获取命令行参数，并构造传递给execve的argv向量。</p>
<p>(3)检查第一个(首个、第0个）命令行参数是否是一个内置的shell命令。</p>
<p>(3)如果不是内部命令，认为是一个可执行文件，则调用fork( )函数创建一个新进程/子进程。如果是内部命令则执行内部命令。</p>
<p>(4)在子进程中，用步骤2获取的参数，调用execve( )执行指定程序。</p>
<p>(5)如果用户没要求后台运行(命令末尾没有&amp;号）否则shell使用waitpid（或wait…)等待作业终止后返回。</p>
<p>(6)如果用户要求后台运行(如果命令末尾有&amp;），则shell返回。</p>
<h2 id="6-3-Hello的fork进程创建过程"><a href="#6-3-Hello的fork进程创建过程" class="headerlink" title="6.3 Hello的fork进程创建过程"></a>6.3 Hello的fork进程创建过程</h2><p>需要引入unistd.h，这时可以调用fork函数获取pid，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span> )<span class="built_in">printf</span>(<span class="string">&quot;it is son&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;\nit is parent&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个简单的例子有一些微妙的方面：</p>
<p>fork调用一次，返回两次。fork函数被父进程调用一次，但是却返回两次，一次返回到父进程，一次是返回到新创建的子进程。</p>
<p>并发执行 ：父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。在我们的系统上运行这个程序时，父进程先完成它的printf语句，然后是子进程。然而，在另一个系统上可能正好相反。一般而言，</p>
<p>作为程序员，决不能对不同进程中指令的交替执行做任何假设。</p>
<p>两个进程的地址空间相同但是独立。如果能够在fork函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。例如，当fork函数返回时，本地变量在父进程和子进程中都相同。然而，因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。后面，父进程和子进程对本地变量所做的任何改变都是独立的，不会反映在另一个进程的内存中。这就是为什么当父进程和子进程调用它们各自的printf语句时，它们中的变量x会有不同的值。</p>
<p>进程共享文件。当运行这个示例程序时，我们注意到父进程和子进程都把它们的输出显示在屏幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用fork时，stdout文件是打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。</p>
<h2 id="6-4-Hello的execve过程"><a href="#6-4-Hello的execve过程" class="headerlink" title="6.4 Hello的execve过程"></a>6.4 Hello的execve过程</h2><p>execve函数在当前进程的上下文中加载并运行一个新程序：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image028-4971512.png" alt="img"></p>
<p>execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。只有当出现错误时，例如找不到filename，execve才会返回到调用程序，并返回-1。所以，与fork一次调用返回两次不同，execve调用一次并从不返回。</p>
<p>后面接着是参数列表argv[]，argv变量指向一个以null结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例，argv[0]是可执行目标文件的名字。环境变量的列表是由一个类似的数据结构表示的，如图8-21所示。envp变量指向一个以null结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如“name=value”的名字-值对。</p>
<p>execve函数加载并运行hello并替代原程序主要有以下几个步骤：</p>
<p>1.删除已存在的用户区域： 删除当前进程虚拟地址的用户部分中的已存在的区域结构。映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中。栈和堆区域也是请求二进制零的，初始长度为零。</p>
<p>2.映射共享区域 ：如果hello程序与共享对象（或目标）链接，比如标准C库libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</p>
<p>3.设置程序计数器（PC）：execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。</p>
<p>之后调度器在下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。</p>
<h2 id="6-5-Hello的进程执行"><a href="#6-5-Hello的进程执行" class="headerlink" title="6.5 Hello的进程执行"></a>6.5 Hello的进程执行</h2><p>进程是在上下文中运行的，每一个程序都运行在某个进程的上下文中，上下文包括了进程运行所需的各种对象的值，包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构。通常情况下，CPU会“同时”执行多个进程，即所谓的并发流(concurrent flow)，并发流的实现依赖于上下文的切换，上下文切换主要有三个步骤：</p>
<p>1.保存当前进程的上下文。</p>
<p>2.恢复某个先前被抢占的进程被保存的上下文。</p>
<p>3.将控制传递给这个新恢复的进程。</p>
<p>上下文切换中，控制会从用户模式移交给内核模式，内核模式比用户模式的权限更大，它能够执行指令集中的任何指令，访问系统中的任何位置，这些权限在上下文切换中是需要的，切换完毕之后控制才会重新移交给用户模式。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度（scheduling），是由内核中称为调度器（scheduler）的代码处理的。当内核选择一个新的进程运行时，我们就说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用上下文切换机制来将控制转移到新的进程。</p>
<p>当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，如果Hello 使用scanf()想要读取用户输入的字符串，内核可以选择执行上下文切换，运行另外一个进程，而不是一直等待直到用户按回车。另一个示例是sleep系统调用，它显式地请求让调用进程休眠。一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。</p>
<p>中断也可能引发上下文切换。比如，所有的系统都有某种产生周期性定时器中断的机制，通常为每1毫秒或每10毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。</p>
<h2 id="6-6-hello的异常与信号处理"><a href="#6-6-hello的异常与信号处理" class="headerlink" title="6.6 hello的异常与信号处理"></a>6.6 hello的异常与信号处理</h2><h5 id="6-6-1下面来解释异常与信号的处理："><a href="#6-6-1下面来解释异常与信号的处理：" class="headerlink" title="6.6.1下面来解释异常与信号的处理："></a>6.6.1下面来解释异常与信号的处理：</h5><p>什么是信号？信号是一个小信息，它能够通知进程系统中发生了某种类型的事件，不同的信号对应于不同的事件，并且有一个异常处理程序来处理这个信号，它与硬件异常处理程序不同，后者交给内核异常处理程序处理，对用户进程而言是不可见的，而前者提供一种机制来通知用户异常的发生,异常有多种类型，通常有终止，停止，故障，中断几种，异常处理程序会根据异常类型的不同采用默认的异常处理函数。</p>
<p>信号处理过程主要有两个步骤：</p>
<p>1.发送信号。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程(可以是自己)。发送信号可以有如下两种原因：1）内核检测到一个系统事件，比如除零错误或者子进程终止。2）一个进程调用了kill函数，显式地要求内核发送一个信号给目的进程。</p>
<p>2.接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序（signal handler）的用户层函数捕获这个信号。图8-27给出了信号处理程序捕获信号的基本思想。</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image029-4971512.png" alt="img"></p>
<p>一个发出而没有被接收的信号叫做待处理信号（pending signal）。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都不会排队等待；它们只是被简单地丢弃。一个进程可以有选择性地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。</p>
<p>一个待处理信号最多只能被接收一次。内核为每个进程在pending位向量中维护着待处理信号的集合，而在blocked位向量中维护着被阻塞的信号集合。只要传送了一个类型为k的信号，内核就会设置pending中的第k位，而只要接收了一个类型为k的信号，内核就会清除pending中的第k位。</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image030-4971512.png" alt="img"></p>
<p>task_struct 维护一个signal结构体</p>
<h5 id="6-6-2-观察各命令及运行结果："><a href="#6-6-2-观察各命令及运行结果：" class="headerlink" title="6.6.2 观察各命令及运行结果："></a>6.6.2 观察各命令及运行结果：</h5><p>未修改过的源代码如下：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sleepsecs=<span class="number">2.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> *argc*,<span class="keyword">char</span> **argv*[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">	   <span class="built_in">printf</span>(<span class="string">&quot;Usage: Hello 119xxx0803 yrs！\n&quot;</span>);</span><br><span class="line">  	  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello %s %s\n&quot;</span>,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">    sleep(sleepsecs);</span><br><span class="line">  &#125;</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>1.</strong> <strong>运行时按下ctrl + Z</strong> <strong>：</strong></p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image031-4971512.png" alt="img"></p>
<p>注：jobs指令可以查看当前后台程序的执行情况。</p>
<p>ctrl+Z 按下后，shell父进程发送一个SIGSTP信号，信号处理程序将hello进程挂起，放到后台，停止hello程序。</p>
<p><strong>2.</strong> <strong>运行时按下ctrl+C :</strong></p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image032-4971512.png" alt="img"></p>
<p>Ctrl + C 会发送一个SIGINT信号，默认行为是将hello程序终止：</p>
<p>**3.**<strong>运行时按回车键：</strong></p>
<p><strong><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image033-4971512.png" alt="img"></strong></p>
<p>在程序运行的时候按下Enter键，会在屏幕上出现换行，但是不会影响程序的运行。最后的getchar 会缓冲区中读取一个回车键，剩下的回车键等终端结束后会换行。</p>
<p>**3.**<strong>运行时乱按：</strong></p>
<p>乱按不会影响程序的运行，但是结束可能会影响shell的下一个指令是什么：</p>
<p><strong><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image034-4971512.png" alt="img"></strong></p>
<p>如果我们先让getchar读入一个回车，然后再输入./hello + 回车：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image035-4971512.png" alt="img"></p>
<p>Shell 会自动启动hello程序，如果是内部命令效果一样,我们在后台挂起两个hello进程，然后在hello运行的时候输入回车 + jobs + 回车得到：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image036-4971512.png" alt="img"></p>
<p>pstree部分分支查看如下：（bash的进程分支）</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image037-4971512.png" alt="img"></p>
<p>接着使用fg调出后台程序运行：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image038-4971512.png" alt="img"></p>
<p>bg后台运行另一个hello程序：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image039-4971512.png" alt="img"></p>
<h2 id="6-7本章小结"><a href="#6-7本章小结" class="headerlink" title="6.7本章小结"></a>6.7本章小结</h2><p>​    本章介绍了hello程序的加载与运行的过程。计算机为每个程序抽象出一个概念为进程，hello以进程的形式运行，每个进程都处在某个进程的上下文中，每个进程也都有属于自己的上下文，用于操作系统通过上下文切换进行进程调度。而且还展示了hello程序的进程执行和异常与信号处理。</p>
<h1 id="第7章-hello的存储管理"><a href="#第7章-hello的存储管理" class="headerlink" title="第7章 hello的存储管理"></a>第7章 hello的存储管理</h1><h2 id="7-1-hello的存储器地址空间"><a href="#7-1-hello的存储器地址空间" class="headerlink" title="7.1 hello的存储器地址空间"></a>7.1 hello的存储器地址空间</h2><p>**逻辑地址(Logical Address)**：逻辑地址也叫相对地址，它运用在没有链接前的重定位目标文件中，逻辑地址要经过寻址方式的计算或变换才得到内存储器中的实际有效地址，查看hello.o中的部分反汇编代码可以看到逻辑地址：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image040-4971512.png" alt="img"></p>
<p>hello.o汇编代码</p>
<p>计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的<strong>物理地址</strong>( Physical Address)与之对应。例如第一个字节的地址为0，接下来的字节地址为1，再下一个为2，依此类推。CPU访问内存的最自然的方式就是使用物理地址。例如hello要读取从物理地址x处开始的4字节字。当CPU执行这条加载指令时，会生成一个有效物理地址，通过内存总线，把它传递给主存。主存取出从物理地址4处开始的4字节字，并将它返回给CPU，CPU会将它存放在一一个寄存器里。</p>
<p>但是现代计算机不会直接地访问物理地址，而是采用虚拟寻址的方式进行地址访问，虚拟地址需要经过翻译才能得到物理地址，<strong>线性地址(Linear Address)<strong>是逻辑地址到物理地址变换之间的中间层，</strong>和虚拟地址意思一样。</strong>例如在分段部件中逻辑地址是段中的偏移地址，加上基地址就是线性地址。</p>
<p>什么是虚拟地址？文件经过重定位之后，能够在内存中访问并运行的地址是<strong>虚拟地址</strong>(Virtual Address)，虚拟地址是现代计算机系统提供的一种对主存的抽象概念。虚拟地址由虚拟内存（VM）来管理，虚拟内存为每个程序提供了一个大的、一致的和私有的地址空间。他将主存看成是一个存储在存盘上的地址空间的高速缓存，为每个进程提供了一致的地址空间，从而简化内存的管理。例如所有的进程包括hello，他们的代码段都是从虚拟地址0x400000（x86-64下）开始的。查看hello中的部分反汇编代码可以看到虚拟地址：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image041-4971512.png" alt="img"></p>
<h2 id="7-2-Intel逻辑地址到线性地址的变换-段式管理"><a href="#7-2-Intel逻辑地址到线性地址的变换-段式管理" class="headerlink" title="7.2 Intel逻辑地址到线性地址的变换-段式管理"></a>7.2 Intel逻辑地址到线性地址的变换-段式管理</h2><p>​    Base + offset 。例如，mov $0x1, %edi指令，段偏移地址为0x25，如果加载后逻辑偏移地址为0x4011b6，那么最终的线性地址为Base + offset=0x4011db. </p>
<h2 id="7-3-Hello的线性地址到物理地址的变换-页式管理"><a href="#7-3-Hello的线性地址到物理地址的变换-页式管理" class="headerlink" title="7.3 Hello的线性地址到物理地址的变换-页式管理"></a>7.3 Hello的线性地址到物理地址的变换-页式管理</h2><p>​    线性地址到物理地址的变换涉及到页表和MMU概念。页表是一个页表条目的数组，虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE，PTE中有一个有效位用来表示该区域是否被已缓存在内存中。</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image042-4971512.png" alt="img"></p>
<p>MMU即分页内存管理单元,MMU位于处理器内核和连接高速缓存以及物理存储器的总线之间,能够将有效地址映射成对应的物理地址，以访问指令和数据。</p>
<p>当hello需要访问一个内存中的地址时，处理器将虚拟地址发送给MMU，</p>
<p>MMU利用虚拟地址对应的虚拟页号生成页表项（PTE）地址，并从页表中找到对应的PTE，如果PTE中的有效位为0，则MMU会触发缺页异常。缺页处理程序选择物理内存中的牺牲页（若页面被修改，则换出到磁盘），缺页处理程序调入新的页面到内存，并更新PTE，缺页处理程序返回到原来进程，再次执行导致缺页的指令：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image043-4971512.png" alt="img"></p>
<h2 id="7-4-TLB与四级页表支持下的VA到PA的变换"><a href="#7-4-TLB与四级页表支持下的VA到PA的变换" class="headerlink" title="7.4 TLB与四级页表支持下的VA到PA的变换"></a>7.4 TLB与四级页表支持下的VA到PA的变换</h2><p>​    TLB介于 CPU 和CPU缓存之间用于缓存一部分标签页表条目，它采用高速缓冲存储器作为页表的Cache，能够加快页表PTE的访问。TLB中保存最近常用的虚拟页号对应的页表条目PTE（含物理页号），MMU 可以直接通过TLB获取PTE中的值，虚拟页数较少的进程页表可以完全在TLB中。 </p>
<p>​    多级页表可理解为一种时间换空间的技术，设计多个页表来大大降低页表占用的空间。由于原有页表中大量的连续PTE条目都是未分配的，Intel64位CPU采用4级页表后，一级页表的PTE 能够访问到4KB的二级页表，大大节省了页表空间。</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image044-4971512.png" alt="img"> </p>
<p>给定一个虚拟地址，MMU会分成多个部分，VPN用来访问页表的元素，如果是k级页表，则需要k个VPN来标记访问的每一个页表的虚拟页号，如下图所示：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image045-4971512.png" alt="img"></p>
<p>最后一级页表保存了PPN，即物理页号，结合物理页面偏移量得到完整的物理地址。</p>
<p>TLB的访问机制为MMU将VPN分成TLB索引和TLB标记两个部分，TLB索引(TLBI)定位TLB中的行，TLB标记（TLBI）与行中的标记位进行匹配，如果匹配成功说明TLB中有需要的PPN，最后完成VA到PA转换。如果没有则通过多级页表进行访问：</p>
<img src="/.com//content/深入理解计算机系统/clip_image046-4971512.png" alt="img" style="zoom:50%;">



<h2 id="7-5-三级Cache支持下的物理内存访问"><a href="#7-5-三级Cache支持下的物理内存访问" class="headerlink" title="7.5 三级Cache支持下的物理内存访问"></a>7.5 三级Cache支持下的物理内存访问</h2><p>现代计算机采用存储器山的结构进行物理内存的访问：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image047-4971512.png" alt="img"></p>
<p>首先CPU会在L1中搜索想要的值，如果找到则直接返回想要的值，如果没有找到，则会从下一级Cache中寻找目标值，如果找到则加载到L1中，替换掉L1中已经存在的牺牲页或空白页（根据不同的替换策略）。如果没有找到则访问下一级Cache，原理相同。</p>
<h2 id="7-6-hello进程fork时的内存映射"><a href="#7-6-hello进程fork时的内存映射" class="headerlink" title="7.6 hello进程fork时的内存映射"></a>7.6 hello进程fork时的内存映射</h2><p>​    fork 函数被shell调用时，内核为hello进程创建各种数据结构，并分配给它一个唯一的PID 。为了给hello进程创建虚拟内存，它创建hello进程的mm_struct 、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork 在hello进程中返回时，hello进程现在的虚拟内存刚好和调用fork 时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image048-4971512.png" alt="img"></p>
<h2 id="7-7-hello进程execve时的内存映射"><a href="#7-7-hello进程execve时的内存映射" class="headerlink" title="7.7 hello进程execve时的内存映射"></a>7.7 hello进程execve时的内存映射</h2><p>在当前进程中的程序执行了execve（”a.out”,NULL, NULL）调用时，execve函数在当前程序中加载并运行包含在可执行文件a.out中的程序，用a.out代替了当前程序。加载并运行a.out主要分为一下几个步骤：</p>
<p>1.删除已存在的用户区域:删除当前进程虚拟地址的用户部分中的已存在的区域结构；</p>
<p>2.映射私有区域:为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在hello中，栈和堆地址也是请求二进制零的，初始长度为零；</p>
<p>3.映射共享区域:hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内；</p>
<p>4.设置程序计数器（PC）:设置当前进程上下文的程序计数器，使之指向代码区域的入口点。</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image049-4971512.png" alt="img"></p>
<h2 id="7-8-缺页故障与缺页中断处理"><a href="#7-8-缺页故障与缺页中断处理" class="headerlink" title="7.8 缺页故障与缺页中断处理"></a>7.8 缺页故障与缺页中断处理</h2><p>7.4节已经完成了分析。</p>
<h2 id="7-9动态存储分配管理"><a href="#7-9动态存储分配管理" class="headerlink" title="7.9动态存储分配管理"></a>7.9动态存储分配管理</h2><p>动态存储分配涉及到对运行时堆的使用，<strong>动态内存分配器</strong>维护着一个进程中的称为堆的虚拟内存区域，brk指向堆的顶部，分配器将堆视为一组不同大小的块的集合来维护，每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。</p>
<p>Hello调用malloc函数，会先访问堆中是否有合适大小的空闲块，如果有相应的空闲块则分配这个块给Hello，返回一个指针指向这个分配块的首地址。如果没有合适的空闲块，系统会拓展堆空间，改变brk的值来保证有合适的空闲块。</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image050-4971512.png" alt="img"></p>
<h2 id="7-10本章小结"><a href="#7-10本章小结" class="headerlink" title="7.10本章小结"></a>7.10本章小结</h2><p>本章简要分析来程序运行时包括页面管理，高速缓存管理，虚拟地址与实地址的转化全流程以及动态内存分配等内容</p>
<h1 id="第8章-hello的IO管理"><a href="#第8章-hello的IO管理" class="headerlink" title="第8章 hello的IO管理"></a>第8章 hello的IO管理</h1><h2 id="8-1-Linux的IO设备管理方法"><a href="#8-1-Linux的IO设备管理方法" class="headerlink" title="8.1 Linux的IO设备管理方法"></a>8.1 Linux的IO设备管理方法</h2><center><strong>万物皆文件！</strong></center>

<p align="right"><strong> ——linux</strong></p>

<p>设备的模型化与管理：Linux下的所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，一个Linux文件是一个m个字节的序列，所有的输入和输出都被当作对相应文件的读和写。这种设备映射为文件的方式，把各种设备硬件的复杂物理特性的细节屏蔽起来，提供一个对各种不同设备使用统一方式进行操作的接口，这样的接口称为Unix I/O，Unix I/O使得输入和输出都能以一种统一且一致的方式的来执行。</p>
<h2 id="8-2-简述Unix-IO接口及其函数"><a href="#8-2-简述Unix-IO接口及其函数" class="headerlink" title="8.2 简述Unix IO接口及其函数"></a>8.2 简述Unix IO接口及其函数</h2><p>UnixIO接口提供了一些的函数来对文件进行操作，例如：open、read和write。</p>
<p>open函数描述如下：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image051-4971512.png" alt="img"></p>
<p>open函数将filename转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags参数指明了进程打算如何访问这个文件:O_ RDONLY:只读；O_ WRONLY:只写；O_ RDWR:可读可写。mode参数指定了新文件的访问权限位。例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = Open(<span class="string">&quot;hello. txt&quot;</span>, <span class="number">0</span>_ CREATIO _TRUNCIO_ _WRONLY, DEF MODE) ;</span><br></pre></td></tr></table></figure>



<p>其余两个函数描述如下：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image052-4971512.png" alt="img"></p>
<p>fd是文件描述符，例如：</p>
<p><img src="/.com//content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/clip_image053-4971512.png" alt="img"></p>
<p>read函数从标准输入设备中读入一个值，存入c中，然后调用write函数将c输出到标准输出设备。</p>
<h2 id="8-3-printf的实现分析"><a href="#8-3-printf的实现分析" class="headerlink" title="8.3 printf的实现分析"></a>8.3 printf的实现分析</h2><p>printf函数可以发送格式化输出到标准输出 stdout中，即显示用户想要显示的字符串到屏幕上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">char</span> *va_list</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> **fmt*, ...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  va_list arg = (va_list)((<span class="keyword">char</span>*)(&amp;*fmt*) + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  i = <span class="built_in">vsprintf</span>(buf, *fmt*, arg);</span><br><span class="line"></span><br><span class="line">  write(buf, i);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> **buf*, <span class="keyword">const</span> <span class="keyword">char</span> **fmt*, va_list *args*)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span>&#123; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* p; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> tmp[<span class="number">256</span>]; </span><br><span class="line"></span><br><span class="line">  va_list p_next_arg = args; </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (p=buf;*fmt;fmt++) &#123; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>) </span><br><span class="line">  &#123; </span><br><span class="line">  	*p++ = *fmt; </span><br><span class="line">	  <span class="keyword">continue</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  fmt++; </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">switch</span> (*fmt) &#123; </span><br><span class="line">	  <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: </span><br><span class="line">  	itoa(tmp, *((<span class="keyword">int</span>*)p_next_arg)); </span><br><span class="line">	  <span class="built_in">strcpy</span>(p, tmp); </span><br><span class="line">  	p_next_arg += <span class="number">4</span>;</span><br><span class="line">  	p += <span class="built_in">strlen</span>(tmp); </span><br><span class="line">	  <span class="keyword">break</span>; </span><br><span class="line">  	<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: </span><br><span class="line">	  <span class="keyword">break</span>; </span><br><span class="line">  	 <span class="keyword">case</span> ....</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  	<span class="keyword">break</span>; </span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (p - buf); </span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure>

<p>printf()通过调用vsprintf函数来解析字符串中的%参数，然后得到整个字符串的长度之后使用Unix I/O函数write()输出到标准输出设备上。</p>
<p>其中，arg指向变量参数，例如printf(“hello %d , %s”, i , name); arg 指向第一个参数i。fmt指向”hello %d, %s”这个字符串。</p>
<p>vsprintf会扫描整个字符串并进行复制直到遇到%（第一个for循环），然后使用swtich对字符串进行修改。</p>
<p>随后调用write函数，其中会调用一个syscall函数，它会执行一个系统调用，根据指定的参数number和所有系统调用的汇编语言接口来确定调用哪个系统调用，例如触发一个陷阱-系统调用。驱动程序去/proc/devieces中申请得到设备名和主设备号，并使用mknod命令建立设备节点文件。通过主设备号将设备节点文件和设备驱动程序联系在一起，然后利用fops函数，绑定应用层的write和驱动层的write。当应用层写一个设备文件的时候，系统找到对应的设备驱动子程序（驱动程序和设备号一一对应），对于printf而言，字符显示驱动子程序根据ASCII根据字模库更新vram。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="8-4-getchar的实现分析"><a href="#8-4-getchar的实现分析" class="headerlink" title="8.4 getchar的实现分析"></a>8.4 getchar的实现分析</h2><p>getchar()是stdio.h中的库函数，它的作用是从stdin流中读入一个字符。</p>
<p>用户通过输入设备输入字符串到内存缓冲区，操作系统执行一个异步异常-键盘中断，这个键盘信号处理子程序将接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。</p>
<h2 id="8-5本章小结"><a href="#8-5本章小结" class="headerlink" title="8.5本章小结"></a>8.5本章小结</h2><p>通过对linux下Unix I/O几个主要函数的阐述分析，讲解了文件的概念及其Unix I/O的原理及其应用。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>​    Hello world的实现是一个复杂的过程，不仅仅涉及到编译器的一系列操作：预处理，编译，汇编，链接…还需要CPU，MMU，内存等硬件，Shell，操作系统和内存管理系统的帮助，Unix I/O接口对文件的支持，最终保证了Hello wold的正确执行。</p>
<h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p><img src="/.com//clip_image054-4971512.png" alt="img"></p>
<p>hello.c 是hello的c语言源程序。</p>
<p>hello.i 预处理之后的文本文件。</p>
<p>hello.s 汇编后的文本文件。</p>
<p>hello.o 可重定位文件hello.o。</p>
<p>hello 从hello.o链接而成的可执行目标文件。</p>
<p>Oelf.d 由可重定位目标文件hello.o生成的elf文件。</p>
<p>Aelf.txt 由可执行目标文件hello生成的elf文件。</p>
<p>Oobj 由可重定位目标文件hello.o反汇编得到的文件。</p>
<p>Aobj 由可执行目标文件hello反汇编得到的文件。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1].   (美)索加，班诺拉．MPC5554 5553微处理器揭秘：北京航空航天大学出版社，2010.11：第47页</p>
<p>[2].   深入理解计算机系统，Computer Systems:A Programmer’s Perspective （美）布赖恩特（Bryant,R.E.） 等</p>
]]></content>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>GS算法学习</title>
    <url>/2021/07/06/GS%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="College-Admissions-and-the-Stability-of-Marriage"><a href="#College-Admissions-and-the-Stability-of-Marriage" class="headerlink" title="College Admissions and the Stability of Marriage"></a>College Admissions and the Stability of Marriage</h1><p><strong>摘要</strong></p>
<p>本文从一个寻找大学录取的方案的问题出发，通过定义稳定性和最优性的原则和对实际问题的抽象等等引导我们找到一种独特的最佳匹配方法，最后对整个文章的论述方法进行了思考和总结。本文参考并总结了D.Gale和L.S.Shapley的经典文章《College Admissions and the Stability of Marriage》并对相关的内容和证明进行了个人解读和补充，在此基础上通过构造例子的方法帮助读者更好地理解本文所阐述的概念和相关证明。</p>
<p><strong>引言</strong></p>
<p>考虑一个典型环境下的一现实问题： 一所大学收到了N个人的申请，但这所大学只有Q个录取名额。招生办需要在评估过申请者之后决定录取哪些人。对大学来说比较理想的选法采用只录取最佳的Q位申请者的录取策略，但在现实中，考虑到申请方可能会同时申请不止一所大学且他们对自己投标的大学有一定的优先级，所以不是所有被这所大学录取的人都会接受录取。</p>
<p><em>例一对招不满的原因进行举例：</em></p>
<p><strong>例子一</strong>：如果一个申请人<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image002-5573600.png?lastModify=1625573877" alt="img">认为<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image004-5573600.png?lastModify=1625573877" alt="img">大学&gt;<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image006-5573600.png?lastModify=1625573877" alt="img">大学&gt;<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image008-5573600.png?lastModify=1625573877" alt="img">大学，在<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image010-5573600.png?lastModify=1625573877" alt="img">大学都愿意录取<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image002-5573923.png" alt="img">的情况下![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image002.png?lastModify=1625573877)就会拒绝<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image008-5573923.png" alt="img">而接受<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image006-5573923.png" alt="img">，那么![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image008.png?lastModify=1625573877)大学就会因为先前已经拒绝了<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image017-5573600.png?lastModify=1625573877" alt="img">之外的申请人后，又因为![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image002.png?lastModify=1625573877)的退出，导致![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image008.png?lastModify=1625573877)大学招不满。</p>
<p>所以这种选法是不够令人满意的，因为一所大学很可能会招不满。因此，为了能招到q位申请者，大学通常会录取多于q个人。</p>
<p>进一步的问题在于应该决定录取多少人、哪些人可以被录取，一定程度上要靠推断来解决。我们不知道某个申请者是否申请了其他学校；即使知道这一点，我们也不知道这些学校在他心中的排名；即便这也知道，我们也不知道哪些其他学校会录取他。所有这些不确定性导致的结果是，学校仅仅只能期望入学人数接近预期录取人数，且学生质量经可能达到最优。</p>
<p>这个问题同时也困扰着申请人。对申请人来说，被要求在申请表中列出所有其他按优先顺序申请的大学的申请人可能会感觉到，或许由于某些原因，如果告诉大学这是他的第三选择，将降低他被这所大学录取的几率。</p>
<p>一种优化方案是引入”备选名单”。这样可以告诉暂未被录取的申请人，虽然他目前没有被这所大学录取，但如果这所大学空出了多余的名额，那么他可能会在之后被录取。但这里引入了新的问题。假设一名申请者被一所大学录取，且同时处于另一所他更喜欢的大学的”等待名单”中。那么他应该保险起见选择前者，还是冒险看看后者之后会不会录取他？如果申请人选择了前者但不通知后者，如果后者在之后若要录取他时，就退掉前者的录取选择后者，这种行为是否有违道德？</p>
<p>如果我们提出一种分配申请者进入大学的程序，这个程序能够满足双方的不同需求，它消除了所有不确定性，在假定有足够的申请者的情况下，将每所大学的配额都能分配给每个合适的申请人。那么我们认为可以避免上述描述的困难。</p>
<p><strong>分配标准</strong></p>
<p>在<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image021-5573600.png?lastModify=1625573877" alt="img">所大学之间分配<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image023-5573600.png?lastModify=1625573877" alt="img">个申请者，其中<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image025-5573600.png?lastModify=1625573877" alt="img">是第<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image027-5573600.png?lastModify=1625573877" alt="img">所大学的配额。每个申请者都按照自己的喜好对大学进行排名，只忽略那些在任何情况下都不愿接受的大学。为方便起见，我们假定任意申请者对自己心仪的大学排名必须有先后（理论上说每一个人最终只能选择唯一一所大学），所以，如果申请人认为两所或多所大学之间没有差别，那么申请人仍然被要求以某种顺序列出他们。每所大学都按照优先顺序对申请该大学的学生进行排名，首先是将那些无论如何都不会录取的申请人淘汰（即使没能录满），因此我们希望从每个大学的录取限额、双方给彼此的排名的数据中，决定一个申请方案以符合某种普遍认同的公平标准。</p>
<p>  有一种方法可能看起来非常显然，即根据所给的偏好数据进行枚举直到选出符合条件的匹配方式。</p>
<p><em>例子二具体展示枚举法的过程：</em></p>
<p><strong>例子二</strong>：假设有申请方<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image029-5573600.png?lastModify=1625573877" alt="img">，大学<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image031-5573600.png?lastModify=1625573877" alt="img">各招一人。申请方的排名：<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image033-5573600.png?lastModify=1625573877" alt="img">，招生办的排名：<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image035-5573600.png?lastModify=1625573877" alt="img">。让<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image037-5573600.png?lastModify=1625573877" alt="img">可满足所有双方的偏好。</p>
<p>但这种匹配方式会存在一个问题，即可能存在任何分配方式都不能满足双方所有偏好的情况</p>
<p><em>例子三、四展示了枚举法不能满足所有偏好的问题：</em></p>
<p><strong>例子三</strong>：假设有申请方<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image039-5573600.png?lastModify=1625573877" alt="img">，大学<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image031-5573600.png?lastModify=1625573877" alt="img">各招一人。申请方的排名：<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image042-5573600.png?lastModify=1625573877" alt="img">，但如果招生办的排名：<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image044-5573600.png?lastModify=1625573877" alt="img">故存在两种匹配方式：<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image046-5573600.png?lastModify=1625573877" alt="img">，前者无法满足招生办的偏好，后者无法满足申请方的偏好。</p>
<p><strong>例子四</strong>：假设有申请方<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image048-5573600.png?lastModify=1625573877" alt="img">，大学<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image031-5573600.png?lastModify=1625573877" alt="img">各招两人。申请方的排名：<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image051-5573600.png?lastModify=1625573877" alt="img">，招生办的偏好排名：<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image053-5573600.png?lastModify=1625573877" alt="img">显然无论那种匹配方式（<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image055.png?lastModify=1625573877" alt="img">），都没有办法满足双方全部的偏好。</p>
<p>如果必须决定如何处理例一这种情况。根据大学是为学生而存在而不是相反的哲学理念，将![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image002.png?lastModify=1625573877)分配给<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image004-5573600.png?lastModify=1625573877" alt="img">并将<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image059.png?lastModify=1625573877" alt="img">分配给<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image006-5573923.png" alt="img">而不是后一种方法或许是合适的，例二同理。这表明了以下公认但模糊的原则：在其他条件相等的情况下，大学应该向申请人妥协。虽然这句话本身并没有多大帮助，但是我们将在处理另一个更明确的问题之后再进行讨论。</p>
<p>  我们希望以下定义中描述的情况在我们选择的匹配中不会发生：</p>
<p>  <strong>定义</strong>：如果分别有两个申请人<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image062.png?lastModify=1625573877" alt="img">和<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image064.png?lastModify=1625573877" alt="img">分别被分配给大学<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image066.png?lastModify=1625573877" alt="img">和<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image068.png?lastModify=1625573877" alt="img">，，但<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image064-5573923.png" alt="img">比去大学<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image006-5573923.png" alt="img">更想去大学<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image072.png?lastModify=1625573877" alt="img">比喜欢<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image074-5573600.png?lastModify=1625573877" alt="img">更喜欢<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image076.png?lastModify=1625573877" alt="img">，这样的匹配方式被认为是<strong>不稳定*<em><strong>的</strong>(unstable)<em>，</em>反之则被认为是</em>*稳定的</strong>(stable)。</p>
<p><em>“An assignment of applicants to colleges will be called unstable if there are two applicants</em> <img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image074-5573600.png?lastModify=1625573877" alt="img"><em>and</em> <img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image076.png?lastModify=1625573877" alt="img"> <em>who are assigned to colleges A and B, respectively, although</em> <img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image076-5573923.png" alt="img"><em>prefers A to B and A prefers B to</em> <img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image074-5573923.png" alt="img">.“</p>
<p><em>例五、例六为理解这个定义的举例：</em></p>
<p>**例子五:**为方便起见，我们观察例子二中<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image082.png?lastModify=1625573877" alt="img">的分配方案，根据稳定方案的定义，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image002.png?lastModify=1625573877)相比去<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image006-5573923.png" alt="img">更想去<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image004-5573600.png?lastModify=1625573877" alt="img"><em>，</em>而<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image004-5573923.png" alt="img">相比录y更想录![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image002.png?lastModify=1625573877)，所以这种方案是不稳定的。</p>
<p><strong>例子六</strong>：存在申请方<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image089.png?lastModify=1625573877" alt="img">，大学<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image091.png?lastModify=1625573877" alt="img">各招一人，申请方：<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image093.png?lastModify=1625573877" alt="img">,而招生办的偏好排名：<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image095.png?lastModify=1625573877" alt="img">,这种情况下有<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image097.png?lastModify=1625573877" alt="img">种方案，根据稳定性的定义，<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image099.png?lastModify=1625573877" alt="img"> 是一种稳定的方案，而<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image101.png?lastModify=1625573877" alt="img">是一种不稳定方案，因为<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image103.png?lastModify=1625573877" alt="img">想去<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image004-5573923.png" alt="img">大于<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image006-5573923.png" alt="img">，而![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)更喜欢<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image103-5573923.png" alt="img">。</p>
<p>假设上述情况的确存在，申请者<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image076-5573923.png" alt="img">将会告诉![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)学校让![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)学校会选择录取![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877) ，撵走<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image074-5573923.png" alt="img">以保持录取名额不变。 ![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)和![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)都会觉得这种改变是一种提升。在这个意义上，若原本的分配方案是“不稳定的”，学校和申请者会以一种对双方都有利的方式抛弃这个方案（注：即使是这样也不一定一步得到稳定方案）。</p>
<p>  以后分析可知，我们对一项匹配方案的第一个要求是它不会表现出不稳定性。但立即出现另一个数学上的问题：是否总是可以找到这样的匹配？下一部分将给出对该问题的肯定答案，尽管证明并不困难，但正如一些例子所示，虽然结果似乎并不十分明显。</p>
<p>  假设目前确实存在稳定的匹配，我们仍然必须确定在许多稳定解决方案中（可能不止一种方案），哪一个是首选。现在，我们回到前面提到的申请人利益大于学校的哲学原则，给出在稳定的解决方案中选出一个最佳方案的精确表述：</p>
<p><strong>定义</strong>：如果每个申请人去的大学都至少比其他稳定方案下去的大学更心仪,那么该稳定方案被认为是<strong>最佳的</strong>，称该方案为<strong>最佳匹配方案</strong>。</p>
<p><em>“A stable assignment is called optimal if every applicant is at least as well off under it as under any other stable assignment.”</em></p>
<p>​    </p>
<p><em>例七、例八为理解这个定义的举例</em>：</p>
<p>  <strong>例子七：</strong>例子二中只存在唯一一种稳定方案（即<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image116.png?lastModify=1625573877" alt="img">）,该方案也是最佳的。</p>
<p>  <strong>例子八</strong>：不难验证，例子六中存在三种稳定方案：1.<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image118.png?lastModify=1625573877" alt="img">、<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image120.png?lastModify=1625573877" alt="img">、<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image122.png?lastModify=1625573877" alt="img">。由于1中的<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image124.png?lastModify=1625573877" alt="img">都分别录取到了自己的第一选择，在方案二和三中<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image124-5573923.png" alt="img">都只能选择第二志愿和第三志愿的配偶，所以1相对于2、3而言每个申请人至少比其他稳定方案下的情况要好，1是最佳匹配方案。</p>
<p>即使保证了稳定匹配方案的存在，但最佳分配是否存在还是无法判断的。但是，很明显的一件事是：</p>
<p><strong>定理一:最佳匹配方案（如果存在）是唯一的</strong>。</p>
<p><em>“**if</em> <em>optimal</em> <em>assignment</em> <em>exists,</em> <em>it</em> <em>is unique*</em>.”*</p>
<p>反证法证明：如果同时存在两个以上的最佳分配方案，由于每一种最佳匹配方案不完全相同，所以至少存在一个申请人在其中的两个方案中所在学校不同，设这两所不同的学校为<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image031-5573600.png?lastModify=1625573877" alt="img">，由于存在申请人对大学的排名偏好，那么一定存在以下情况之一：<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image128.png?lastModify=1625573877" alt="img">或<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image130.png?lastModify=1625573877" alt="img">，无论是哪一种情况都会存在一种方案比另一种方案要好的情况，与最佳匹配方案定义矛盾，结论得证。</p>
<p>因此，一个分配毕竟不是最佳的。解决存在的问题后，稳定性和最优性原则将引导我们找到独特的最佳分配方法。</p>
<p><strong>稳定申请与婚姻问题</strong></p>
<p>尝试去解决我们之前提出的稳定申请问题之前，先来考虑另一种特殊情况，即大学申请的人数和学校的人数一样的情况，虽然有点不自然，但考虑另一种相对比较恰当的情景：</p>
<p>在某一社区中有<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image023-5573600.png?lastModify=1625573877" alt="img">个男士和<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image023-5573923.png" alt="img">个女士，每一个人都是根据他/她对婚姻对象的偏好来对每一个异性进行排名。现在我们需要一个令人满意的方案将这个社区中的![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image023.png?lastModify=1625573877)个男士和![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image023.png?lastModify=1625573877)个女士互相配对，根据先前不稳定匹配方案的定义，称为<strong>一组不稳定婚姻的匹配方案</strong>（上述概念明显适用），如果在这个方案下有一个男孩和一个女孩不是彼此结婚，而是彼此相对自身的实际伴侣而言更喜欢彼此。</p>
<p><strong>问题一</strong>：任意一种偏好排名都可以找到一组稳定匹配方案吗？</p>
<p><strong>例子九</strong>：图一为一个“排名矩阵”，有三个男孩<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image136.png?lastModify=1625573877" alt="img">和三个女孩<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image138.png?lastModify=1625573877" alt="img"> </p>
<p><img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image139.png?lastModify=1625573877" alt="A close up of a clock  Description automatically generated"></p>
<p>矩阵中每对的第一个数字给出了男孩对女孩的排名，第二个数字是女孩对男孩中的排名。因此，对于<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image074-5573923.png" alt="img">来说，<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image142.png?lastModify=1625573877" alt="img">，而对于![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)而言，<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image145.png?lastModify=1625573877" alt="img">，依此类推。有六对可能的婚姻（<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image097.png?lastModify=1625573877" alt="img">）；其中有如下三个方案是稳定的：一是通过给每个人自己的第一选择来实现的，即<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image148.png?lastModify=1625573877" alt="img">。请注意，这种情况每个女孩都配对自己最低排名的男孩，但方案对男孩来说仍然稳定。另一种方案是让女性优先选择自己最佳的排名，即：<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image150.png?lastModify=1625573877" alt="img">,第三种方案是让每个人都和第二选择匹配，即<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image152.png?lastModify=1625573877" alt="img">。其他情况易证不是稳定的匹配方案，例如：<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image154.png?lastModify=1625573877" alt="img">，因为![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)想去<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image006-5573923.png" alt="img">大于想去![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)，而![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)相对![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)来说更喜欢![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877),所以不是稳定方案。</p>
<p><strong>例子十：</strong>图二为排名矩阵，四个男孩<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image162.png?lastModify=1625573877" alt="img">，四个女孩A,B,C,D .</p>
<p><img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image163.png?lastModify=1625573877" alt="A drawing of a person  Description automatically generated"></p>
<p><strong>图二</strong></p>
<p>矩阵中带圆圈的条目表示唯一的一组稳定的方案。请注意，在这种情况下，要实现稳定性，任何人都无法获得他或她的第一选择。</p>
<p>与婚姻问题类似的一个问题是室友的问题。男孩们希望分成成对的一对室友。如果在其下没有两个男孩，则一对配对被认为是<strong>稳定的</strong>。不是室友的两位男孩，彼此都比真正的室友更喜欢彼此。一个简单的例子表明，在某些情况下可能没有稳定的配对，即考虑男孩![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)，<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image167.png?lastModify=1625573877" alt="img">和<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image169.png?lastModify=1625573877" alt="img">，其中![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)排![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)第一， ![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)将<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image167-5573923.png" alt="img">排第一，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image167.png?lastModify=1625573877)将![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)排第一，而![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image167.png?lastModify=1625573877)则全部排<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image169-5573923.png" alt="img">在“最后”，然后不管![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image169.png?lastModify=1625573877)的偏好如何，都无法稳定配对，因为与![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image169.png?lastModify=1625573877)一起住的人无论他是谁都想搬出去，而另外两个人的其中一个都愿意接受他。</p>
<p><strong>例子十一：</strong><img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image183.png?lastModify=1625573877" alt="img">比喜欢<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image185.png?lastModify=1625573877" alt="img">更喜欢![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)喜欢<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image062.png?lastModify=1625573877" alt="img">更喜欢<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image190.png?lastModify=1625573877" alt="img">。</p>
<p><strong>定理二</strong>：婚姻问题中，一定存在稳定的婚姻匹配方案</p>
<p><em>“There always exists a stable set of marriages.”</em></p>
<p>证明：我们将通过给出实际找到稳定方案的迭代过程来证明该方案的存在。首先，让每个男孩向他最喜欢的女孩求婚。每个收到多个求婚新的女孩都会留下求婚者中最心仪的一位男孩（根据偏好排名），拒绝掉其他的男孩。但是她还不接受他，而是让他处于候选名单中，给予更好的男孩求婚的机会。现在我们准备第二阶段。那些被拒绝的男孩现在向了他们的第二选择求婚。每个收到求婚的女孩都会从新求婚者和名单中的男孩（如果有）中选择自己最喜欢的一个，然后拒绝掉所有其余的男孩，因而再次保留了最爱。我们以相同的方式进行迭代。那些在第二阶段被拒绝的人会求助于他们的下一个选择，而女孩们再次拒绝了他们迄今为止所拥有的最好的建议。</p>
<p>实际上，最多<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image192.png?lastModify=1625573877" alt="img">轮求婚回合（结论附方案的存在性），每个女孩最终都会得到一个男孩，因为男孩和女孩的数目一样(实际上可以不一样，后面会讨论)，由<strong>抽屉原理</strong>可知，只要存在一个女孩没有被求婚，那么必存在两个男孩或两个以上的男孩在追求同一个女孩，根据规则必有男孩会被这个女孩拒绝，进而有引发新一轮的求婚，由于男孩们不可以多次对同一个女孩求婚，所以每个女孩一定会在适当的时候收到某个男孩的求婚。最后一个女孩得到她的“如意郎君”之后，求婚游戏结束，每个女孩子都需要接受在他们清单上的男孩。</p>
<p>我们断言<strong>这种延迟接受**</strong>(<em><strong><strong>deferred acceptance</strong></strong></em>)**<strong>的选法是稳定的</strong>。</p>
<p>反证法证明：假设存在两个男孩和一个女孩分别是约翰和玛丽，约翰没有和玛丽结婚，但约翰比喜欢自己的妻子来说更喜欢玛丽。然后，约翰一定在某个回合向玛丽求婚了，且被玛丽拒绝了才有可能出现和实际配偶结婚的情况，现在很明显，玛丽必须比约翰更喜欢她的丈夫，因为玛丽不会去选择比不喜欢约翰更不喜欢的人。</p>
<p><em>例子十二演示延迟接受法的具体过程：</em></p>
<p><strong>例子十二：</strong>用上述方法找出图三的一个稳定方案：</p>
<p><img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image193.png?lastModify=1625573877" alt="A picture containing clock  Description automatically generated"></p>
<p><strong>图三</strong></p>
<p><strong>第一轮</strong>：<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image195.png?lastModify=1625573877" alt="img">根据第一志愿对配偶进行求婚，由图可知，<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image197.png?lastModify=1625573877" alt="img">然后![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)会将![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)拒绝（因为<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image201.png?lastModify=1625573877" alt="img">更喜欢![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)，下面同理）,把![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)放到候选名单中，<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image010-5573600.png?lastModify=1625573877" alt="img">分别把<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image206.png?lastModify=1625573877" alt="img">放到候选名单中；<strong>第二轮</strong>：被拒绝的![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)向第二志愿的<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image209.png?lastModify=1625573877" alt="img">求婚，<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image006-5573923.png" alt="img">拒绝![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image167.png?lastModify=1625573877)而把![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)放入候选名单，其他人保持不变;<strong>第三轮</strong>：被拒绝的![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image167.png?lastModify=1625573877)向第二志愿![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image008.png?lastModify=1625573877)求婚，C会拒绝![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image169.png?lastModify=1625573877)而把![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image167.png?lastModify=1625573877)放到候选名单中，其他人保持不变；<strong>第四轮</strong>：被拒绝的![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image167.png?lastModify=1625573877)向第二志愿<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image219.png?lastModify=1625573877" alt="img">求婚，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877) 会拒绝掉![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)而把![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image169.png?lastModify=1625573877)放到候选名单中，其他人保持不变；<strong>第五轮</strong>：被拒绝的![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)向第三志愿![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image008.png?lastModify=1625573877)进行求婚，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image008.png?lastModify=1625573877)会拒绝![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image167.png?lastModify=1625573877)而把![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)放到候选名单中，其他人保持不变；<strong>第六轮</strong>：被拒绝的![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image167.png?lastModify=1625573877)向第三志愿A求婚，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)会拒绝![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image169.png?lastModify=1625573877)而把![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image167.png?lastModify=1625573877)放到候选名单中，其他人保持不变；<strong>第七轮</strong>：被拒绝的![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image169.png?lastModify=1625573877)向第三志愿![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image006.png?lastModify=1625573877)求婚，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image006.png?lastModify=1625573877)会拒绝![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)而把![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image169.png?lastModify=1625573877)放到候选名单；<strong>第八轮</strong>：被拒绝的![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)向第三志愿C求婚,![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)会再次被拒绝，<strong>第九轮</strong>：![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)向最后志愿<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image241.png?lastModify=1625573877" alt="img">求婚，<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image241-5573923.png" alt="img">由于没有被求婚过所以把![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)放到候选名单中。<strong>第十轮</strong>：![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)选择![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image167.png?lastModify=1625573877)，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image006.png?lastModify=1625573877)选择![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image169.png?lastModify=1625573877)，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image008.png?lastModify=1625573877)选择![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image241.png?lastModify=1625573877)选择![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image076.png?lastModify=1625573877)。匹配结束。</p>
<p>男孩和女孩人数相同的条件不是必须的。如果有<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image253.png?lastModify=1625573877" alt="img">个男孩和<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image255.png?lastModify=1625573877" alt="img">个女孩，当<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image257.png?lastModify=1625573877" alt="img">时，只要<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image253-5573923.png" alt="img">个女孩都被求过婚，那么过程结束。当<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image260.png?lastModify=1625573877" alt="img">时，当每个男孩都落在某个女孩候选名单上或被所有女孩拒绝时，该过程结束。无论哪种情况，最终形成的婚姻都是稳定的，证明方法同上。</p>
<p>而显然，这是完全对称的程序，如果女孩向男孩求婚，男孩使用候选名单，这也必定导致稳定的婚姻。两种解决方案通常不完全相同（如例子八）；确实，我们稍后会看到，当男孩求婚时，延迟接受对于男孩来说是最佳的，而当女孩求婚时，延迟接受对于女孩来说是最佳的。当且仅当存在唯一稳定的婚姻匹配方案时，这两个过程的解决方案才是相同的。</p>
<p><strong>录取问题下的延迟接受方案</strong></p>
<p>将上述延迟接受的选法扩展到大学录取问题是同理的。为方便起见，我们将假承认第二节所述的情况：如果大学在任何情况下都不愿意接受学生，则该学生甚至不能被允许申请该大学（注：如同男孩不能同时向一个女孩求婚两次）。有了这样的理解，程序就可以遵循以下步骤：首先，所有学生都应选择他们的第一志愿。然后，配额为<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image262.png?lastModify=1625573877" alt="img">的大学将其排名最高的![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image262.png?lastModify=1625573877)个申请人（如果少于![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image262.png?lastModify=1625573877)则为录取所有申请者）放在其候选名单中，并拒绝多余的申请人。被拒绝的申请者然后申请第二志愿，每所大学再次从新申请者和其候补名单中选择排名最高的![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image262.png?lastModify=1625573877)个申请人，将其放入新的候补名单，然后拒绝其余的。当每个申请人都在等待名单上或被他想要得到认可的所有大学统统拒绝时，该程序即告终止。此时每所大学允许在等待名单上的![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image262.png?lastModify=1625573877)个人录取，并且稳定的分配已经完成。分配稳定的证明与婚姻问题的证明完全相似，![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image262.png?lastModify=1625573877)和<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image269.png?lastModify=1625573877" alt="img">的大小不影响方案的稳定性。</p>
<p><strong>最佳性*****(*<em><strong><strong>Optimality*</strong></strong></em>)*</strong></p>
<p>我们下面将说明延迟接受方案不仅对申请人来说是稳定的，也是最佳的。</p>
<p><strong>定理三</strong>：每个申请人在延期接受方案下至少比在其他稳定方案要好。</p>
<p><em>“Every applicant is at least as well of under the assignment given by the deferred acceptance procedure as he would be under any other stable assignment.”</em></p>
<p>注：如果存在一个稳定的分配方案，把某位申请者分配给了某所大学，则称这所大学对于这位申请者来说是<strong>可能的**</strong>(<em><strong><strong>possible</strong></strong></em>)<strong>。要想证明每一个申请人在延期接受的方案下至少比其他稳定方案要好，那只需证明这个延期接受方案下，每一个申请人都不会被</strong>可能的<strong>学校拒绝。因为如果这个延期接受方案下存在一个申请人被</strong>可能的**学校拒绝，那么让这个申请人被可能的学校录取就会让这个申请人变得更好。</p>
<p>证明：采用归纳法。当没有求婚时，显然没有人被拒绝。假设在某一时刻，还没有申请者被他“可能的”学校拒绝。如果这个时候，已经招满了申请者 <img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image271.png?lastModify=1625573877" alt="img">的大学![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)拒绝了申请者![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)，那么我们要说明，大学![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)对于申请者![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)来说是<strong>不可能</strong>的。由于除去那些拒绝了他的学校之外，大学<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image277.png?lastModify=1625573877" alt="img">最喜欢的学校。因此根据假设，这些拒绝他的学校对<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image279.png?lastModify=1625573877" alt="img">来说是不可能的。假设有一个方案，把![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)分配给![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)。那么在这个方案中，至少有一位申请者<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image279-5573923.png" alt="img">被分配给了对![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image279.png?lastModify=1625573877)来说比![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)更不喜欢的学校。但这样，方案就不稳定了，因为![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image279.png?lastModify=1625573877)与![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)彼此都更想选择对方。因此这个方案不稳定，从而说明![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png?lastModify=1625573877)对![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image074.png?lastModify=1625573877)来说不可能。所以此时，仍然没有申请者被他“可能的”学校拒绝，归纳法成立。这样就归纳得出，我们的方案中，大学只拒绝了那些在任何稳定方案中都不可能的学生。因此结果是最优的。</p>
<p>附带地讲，我们可能会说，即使我们不再具有婚姻问题的对称性，我们仍然可以颠倒录取程序以获得唯一的“大学最佳分配。颠倒的方法与兄弟会有些相似；首先是每所大学向其认为最可取的那些申请人以名额，直至达到名额上限，然后学生留下最有吸引力的报价，拒绝剩下的邀请，同理依此类推。</p>
<p>到目前为止一直关注我们的读者无疑会注意到我们讨论中的某种趋势。在做出必要的特殊假设来从数学上分析我们的问题时，我们必须抛开原来的大学录取问题，和最终的婚姻问题，我们放弃现实，进入一个可信的**(make-believe)**数学世界。务实的读者可能会问这样是否对实际解决原始问题做出了任何贡献。即使是对此问题的粗略回答，也需要涉及非数学问题，在数学杂志中不讨论这种非数学的问题。但是，我们认为，此处介绍的某些思想可能会有用地应用于大学申请问题的某些阶段。</p>
<p><strong>总结</strong></p>
<p>最后，我们提请注意前述分析的数学老师可能会感兴趣的另一个方面。这是事实，我们的结果为非数学人士认为数学与之有关的某些刻板印象提供了一个方便的反例。大多数数学家一次或一次发现自己很容易反驳他们是“装数字的大脑”或“知道很多数学公式”。 在这种情况下，可能需要手头上的插图来表明数学不必与数字或几何图形有关。为此，我们建议对定理1进行陈述和证明并不用数学符号表示，而是用口语来表示、没有模糊或专业术语、没有微积分知识。可能只需要知道如何计数；任何数学家都会立即认出该论点是数学的，而人们没有经过数学训练的人可能会很难理解论点，尽管这不是对主题不熟悉的一个原因，然而，任何数学家都能立刻认识到数学化的论证过程，而没有受过数学训练的人将可能发现自己难以跟上论述的步调，尽管这并不是因为不熟悉讨论的主题</p>
<p>那么，又要提出这个古老问题的是什么数学呢？答案似乎是，任何以足够精确进行的论证都是数学，而您和我们的朋友们无法理解数学的原因不是因为他们没有装数字的脑袋，而是因为他们无法没有论述的顺序渐进所需的专注度。对于从事数学教学的人来说，这种观察几乎不是什么新闻，但是，该专业人士可能不那么容易接受这种观察。上面的内容或许对他们有一些帮助。</p>
<p>  注：具有<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image192.png?lastModify=1625573877" alt="img">轮求婚回合的方案：先让<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image291.png?lastModify=1625573877" alt="img">个男孩子分别向![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image291.png?lastModify=1625573877)个女孩子求婚，然后剩下的那个男孩子轮流和![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image291.png?lastModify=1625573877)个女孩子求婚,让他被拒绝<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image295.png?lastModify=1625573877" alt="img">次，最后一次让他求婚成功，结果是另外一个男孩子被甩，然后再让被甩的男孩子轮流被这![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image291.png?lastModify=1625573877)个女孩子拒绝<img src="/.com//../../Typora%E5%9B%BE%E7%89%87/clip_image295-5573923.png" alt="img">次，最后一次让他成功….依次循环直到前面的![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image291.png?lastModify=1625573877)个的男孩子都被拒绝n-2次，然后最后一次有一个男孩子被原来![img](file:////Users/yrs/Library/Group Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image291.png?lastModify=1625573877)个女孩子拒绝后和从没被求婚过的女孩子在一起，每次当所有的男生都求完婚时，算一个轮次，所以这个方案构造出的被拒绝的次数（除最后一次）和轮次数一样：所以结果是<img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image301.png?lastModify=1625573877" alt="img"> = <img src="file:///Users/yrs/Documents/Typora%E5%9B%BE%E7%89%87/clip_image303.png?lastModify=1625573877" alt="img">次。</p>
<p><strong>参考文献</strong></p>
<p>[1] D.Gale、L.S.Shapley 《College Admissions and the Stability of Marriage》[M] 1962,9-15</p>
]]></content>
  </entry>
  <entry>
    <title>软件构造笔记</title>
    <url>/2021/07/07/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>首先：<strong>内存忽略，死锁不考。题型是选择，大题。</strong></p>
<h5 id="Ch1"><a href="#Ch1" class="headerlink" title="Ch1:"></a>Ch1:</h5><p>必考表格.</p>
<p>质量目标及折中时可能会产生的冲突. </p>
<h5 id="Ch2"><a href="#Ch2" class="headerlink" title="Ch2:"></a>Ch2:</h5><p>测试的概念和分类.</p>
<p>等价类划分.需要考虑特殊情况(0 和变量边界(如INT_MIN) . Ch2 </p>
<p>白盒不会考大题:      测试程序内部运转,确保路径能够正确执行到,无法测试程序功能(黑盒可以).考概念:独立/基本路径测试:对于每一个等价类划分都能有正确的路径跳转.</p>
<h5 id="Ch3"><a href="#Ch3" class="headerlink" title="Ch3:"></a>Ch3:</h5><h5 id="Ch4"><a href="#Ch4" class="headerlink" title="Ch4:"></a>Ch4:</h5><p>1.对象和基本数据类型的特性表格:<img src="/.com//yrs/Documents/Typora%E5%9B%BE%E7%89%87/image-20210517081602167.png" alt="image-20210517081602167"></p>
<p>2.静态类型检测和动态类型检测</p>
<p>3.(必考)区别是否mutable, 如果不是就设计一个mutability,  比如给一个类, 修改类的private final ….r</p>
<p><img src="/.com//yrs/Documents/Typora%E5%9B%BE%E7%89%87/image-20210517085007348.png" alt="image-20210517085007348"></p>
<p>不允许改变变量的数据类型,直接return变量的引用肯定不是immultable,改变参数的值也一定不是immultatble</p>
<p>The following things are essential for creating an <strong>immutable</strong> class:</p>
<p>[Mutable and Immutable in Java - Javatpoint](<a href="https://www.javatpoint.com/mutable-and-immutable-in-java#:~:text=Mutable">https://www.javatpoint.com/mutable-and-immutable-in-java#:~:text=Mutable</a> and Immutable in Java Java is an,object-based concept is mutable and immutable in Java.)</p>
<ul>
<li>Final class, which is declared as final so that it can’t be extended.</li>
<li>All fields should be private so that direct access to the fields is blocked.</li>
<li>No Setters，即不能有变值器。</li>
<li>All mutable fields should be as final so that they can not be iterated once initialized.</li>
<li></li>
</ul>
<p>String类型是immutable的,而StringBuilder类型是mutable的。<strong>基本数据型都是immultable</strong> .</p>
<img src="/.com//yrs/Documents/Typora图片/image-20210524082727915.png" alt="image-20210524082727915" style="zoom:20%;">



<p><strong>Snapshort</strong> diagram 单圈和双圈(mul or immul ),单线头和双线头(final or not ).<strong>会考</strong></p>
<p>Java collections 可以保证list是不可变的,但是这种转换<strong>在动态检测的时候获得的</strong>,在静态检测的时候无法检查得出,因为list.remove被编译器认为合法..</p>
<p><strong>ch5</strong> </p>
<p>​    <strong>给定规约(specification),判断规约的强弱</strong>,给操作写规约</p>
<p>规约的描述可以被静态类型检测,但方法的注释不可以被检测</p>
<p>规约:功能描述(参数,参数要求) +函数调用 + 告诉对应的输出.不能带有实现细节告诉给客户.</p>
<p>之前的编程想法要记录,即为设计决策.</p>
<p>前置条件不满足,后置条件无效.</p>
<p>对输出参数进行改变的方法(multable)需要在规约中提示,所以尽量不选择.</p>
<p>规约强弱判断方法：如果前置条件比较更弱（precondition）;后置条件更强;more client can use it;fewer implementations satisfy it .</p>
<p><strong>ch6:ADT抽象数据型</strong></p>
<p>给一类，表示会不会出现表示泄漏。</p>
<p>检查是否有public ，如果有改成private</p>
<p>给定一个操作，判断是什么类型的方法。种类有：</p>
<p>1.Creator构造器：给一个对象创建一个新对象。</p>
<p> Producer : 给一个对象创建一个不同类型的对象：see ch6 P53 即是pro 也是crea</p>
<p>工厂方法是为了创建一个实例，通常是<strong>静态方法？</strong> :String.ValueOf(object obj);无需创建对象就可以直接通过类名调用。</p>
<p>Q： Creators 和 producers 的区别.example : SubString(int, int);</p>
<p>2.表示空间-&gt;抽象空间的映射不一定是双射，但一定是满射，因为客户设计的东西一定在表示空间中有意义，另一方面，表示空间上不同的两个值在客户看来其实是一样的。</p>
<p>判断一个Map是否满足满射，单射，双射。给定一个RI和AF，判断哪些值是符合的。</p>
<p><strong>判断哪一个注释是用户/非用户看到的，判断哪一个Rep能够支撑某个函数，判断哪一个是RI的表述。see :ch6 68.</strong>   ： RI，AF, Safety from Rep exposure, Rep invariant 是给程序员看的。ADT的规约是按照Client的要求来进行书写的，规约要根据用户输入的类型和方法使用来进行异常的抛出和值的输出。</p>
<p>note : 每年都有一个判断改变R值但是不影响用户方面的immutable.</p>
<p>Presentation Independent  and Presentation Invariant</p>
<p>3.RI :用于判断某个具体的“表示”是否”合法“的规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RI : R -&gt; <span class="keyword">boolean</span> <span class="comment">//RI 数据校验函数。</span></span><br></pre></td></tr></table></figure>

<p>AF : 用于给出抽象空间在表示空间中的表示。</p>
<p><strong>大题： 类的独立性即：</strong></p>
<p>不能暴露属性。</p>
<p>不能return 原引用，因为直接return 是把对象的地址引用给了返回的变量，client 可以直接访问类里面的值。<img src="/.com//yrs/Documents/Typora图片/image-20210524094203899.png" alt="image-20210524094203899" style="zoom:25%;"></p>
<p>====</p>
<p>Rep exposure : presents a reason why the code doesn’t expose the rep:</p>
<img src="/.com//yrs/Documents/Typora图片/image-20210531082604611.png" alt="image-20210531082604611" style="zoom:25%;">  



<h3 id="ch7-选择题和代码修改题"><a href="#ch7-选择题和代码修改题" class="headerlink" title="ch7 选择题和代码修改题"></a><strong>ch7 选择题和代码修改题</strong></h3><p>JVM无法在编译阶段（整个阶段）都无法识别multable的子类调用multable的接口.</p>
<p>接口的方法没完全实现会出问题。</p>
<p>Q: return new FastMyString(); (FastMyString 是接口的一个具体实现)</p>
<p>。接口，继承，重写抽象类考题：给一道题分析执行结果。</p>
<p>note : 子类的规约应该比父类的规约更强。</p>
<p><strong>what does this print : false ;(ch7.p69)</strong>:理由是因为contains的实现是调用了Object 的equals方法，而object 的equals方法判断的是object 的类型。</p>
<p>instanceof 判断a 是否为该类型或该类型的父类，getClass直接给出a的类型。</p>
<p>带范型的T&lt;&gt;，只要范型不一样，则两者没有直接父子关系。</p>
<p>hashcode只需要保证每一个key的值不同。</p>
<p>Q collection,通配符;</p>
<p>final 只赋值一次。</p>
<p><strong>ch8</strong></p>
<p>​    观察者角度看如果两个对象调用<strong>任何</strong>相同的操作都会的得到相同的结果，则可以看作是一样的。行为等价性：做相同的变化也会得到一样的结果。特别地，没有方法的类对所有的对象都等价</p>
<p>所以考试会考用AF 和给一些方法来让你判断两个新生成的对象是否等价。</p>
<p>== VS equals :== 是判断是否值相同。 考虑选择不同的对象有不同的hashcode.</p>
<p>行为等价性  ： multable 来说，要对象一样。 imultable 来说，要值不变。是一整个时间线的不变。</p>
<p>观察等价性： multablxe observer 得到的值都一样。</p>
<hr>
<p>Map&lt;String , Integer &gt;  m = …</p>
<p>m.put(‘a’, 1 ); 对1 来说会调用一个valueOf来打包一个Integer类型的对象。valueOf会使用常量池技术。</p>
<hr>
<p>clone 方法。</p>
<p><strong>表示泄漏 presentation exposure</strong>. defensive copy。clone 方法是浅拷贝，对象内属性引用的对象只会拷贝引用地址，而不会将引用的对象重新分配内存，相对应的深拷贝则会连引用的对象也重新创建。</p>
<p><strong>ch9</strong>：</p>
<p>了解概念</p>
<p>framework 调用主控端在框架端，Library调用在用户端。</p>
<p>Q : 擦拭法</p>
<p><img src="/.com//../../Typora%E5%9B%BE%E7%89%87/image-20210707134403640.png" alt="image-20210707134403640"></p>
<p>but ： List<Number>. is not a subtype of List<Object>;</Object></Number></p>
<p><strong>ch10：</strong></p>
<p>考察：下面那个原则是好的原则.</p>
<p>Open/close 原则： 复用多的方法建议放在interface中抽象。避免多个ifelseifelse.</p>
<p>interface</p>
<p><strong>必考正则表达式</strong>： 复习一下<a href="https://www.runoob.com/java/java-regular-expressions.html">Java 正则表达式</a> 可能是选择题（唯一）。terminal ::= interminal </p>
<p>可能会考语法树。</p>
<p>a ::= word* := [0-9]+</p>
<p><strong>ch11:</strong></p>
<p>设计模式 ： 工厂模式，策略模式，修饰器模式。</p>
<p>委托：动态编译时确定的。</p>
<p>用继承方法去组合多个功能的子类，会产生很多重复的代码（不同的具体要求类会选取子类来继承）</p>
<p>Q：适配器</p>
<p>Q : protected</p>
<p>Q: 两个修饰器指向需不需要修改成super()。</p>
<p>修饰器</p>
<p>策略模式如果一个类中有一个方法有不同的实现方式，那么构造一个接口并分别实现不同方法的类</p>
<p>与观察模式不同的是， 由于观察模式依赖于服务类，所以需要产生对服务类中的方法和变量的访问</p>
<p><strong>ch12：</strong></p>
<p>正确性和健壮性的概念</p>
<p>private 中通过RI, checkRep来保证正确性，不需要考虑健壮性。</p>
<p>错误与异常。‘”错误“是无法修复的错误，异常是可以通过对程序进行修复而继续运行程序。</p>
<p>异常两类：RuntimeException 和CheckedException,前者是程序猿出现的代码错误，后者是可以修复的外部输入。</p>
<p>Java 中的 Finally 关键一般与try一起使用，在程序进入try块之后，无论程序是因为异常而中止或其它方式返回终止的，finally块的内容一定会被执行 。<a href="https://blog.csdn.net/w605283073/article/details/103841999">see</a> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span> 无论<span class="keyword">catch</span>执行哪一个，执行后就会执行<span class="keyword">finally</span>.</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;<span class="keyword">finally</span> </span><br><span class="line">  &#123;</span><br><span class="line">   	<span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">  &#125;<span class="comment">// 最终会返回false;</span></span><br></pre></td></tr></table></figure>

<p>调用某个类的时候throws IOException, 提示生成这个对象的时候要写异常。checkExcption是无法修复的异常，是需要修改代码的异常不需要抛出(掩耳盗铃)。</p>
<p>前置后置异常，黑盒等价类划分。</p>
<p>throws 抛出异常？标记功能？</p>
<p>编译器检查什么来这</p>
<p>extends 继承</p>
<p>断言assert用于开发阶段，目的是为了尽早发现程序员的错误，异常不会直接退出程序，用于提供一种程序错误的处理方式。</p>
<p>考试考黑盒测试，有效输入和无效输入。</p>
<p>设置路障：第一部分用于接受用户错误，用异常来处理; CheckRep用Assert来检测那些对属性改变的private。</p>
<p>SpotBug不考。</p>
<p><strong>复习</strong>：</p>
<p>1.Multable 和imultable</p>
<p>2.表示报漏概念和怎么解决</p>
<p>3.规约，判断强弱，画图圈</p>
<p>4.给个代码Snapshot diagram</p>
<p>5.判相等方法： ==，equals， 相等的对象hashcode要一样，不同的</p>
<p>行为等价性 multable Stringbuilder 两个”123” 不想等。</p>
<p>static</p>
<p>override 和overload</p>
<p>The <strong>mutator</strong> method in java, <strong>mutator also mean setter</strong>.and any object-oriented programming language, is a method that enables you to change the variables inside the class. Private is the access-level for the variables, meaning the only way to change the variables is by using the mutator methods. </p>
<p><img src="/.com//../../blog/source/content/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210705112817850.png" alt="image-20210705112817850"></p>
<p>Collection下面有Set Map LIst Queue Stack .</p>
<p><a href="https://www.cnblogs.com/yxnchinahlj/archive/2010/09/20/1831615.html">JAVA深复制(深克隆)与浅复制(浅克隆) - 白了少年头 - 博客园 (cnblogs.com)</a></p>
<p><img src="/.com//../../Typora%E5%9B%BE%E7%89%87/image-20210705121752142.png" alt="image-20210705121752142"></p>
<p><strong>但是mutator 不一定是void 返回的</strong> </p>
<p>Q:</p>
<p>check异常和uncheck异常。</p>
<p>常见类的方法，哪些类重写了基本方法。</p>
<p>测试。</p>
<p>printStackTrace()</p>
<p>接口的方法定义。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Cartographer(Java)</title>
    <url>/2021/05/30/Cartographer%EF%BC%88java%EF%BC%89/</url>
    <content><![CDATA[<p>大二下刚开学和shl一起参加了航天创意物流比赛，刚开始想着两个人去试试水，随便玩一下，后来开学没多久，因为一起参加比赛的另一支队伍缺员，于是两队考虑合并，至此之后就开始有点团队合作来学习了。整个比赛分为好几个部分，我主要负责一些路径规划的东西，因为大二上的时候学过数据结构，做的比较快就开始做SLAM建图，第一次阅读工程代码，同时阅读英文技术文档，说实话还是挺有意思的，最近比较忙，分享一下我没整理的学习笔记。</p>
<p><strong>Cartographer.</strong></p>
<p>算法理解:如图所示，可以看到cartographer 主要分为两大部分，一个是用来建立一系列子图(submap)的Local SlAM，算法接受到由传感器从环境中获取的数据，经过Voxel Filter，Voxel Filter的功能是将原始点降采样为恒定大小的多维数据集并且仅保留每个多维数据集的质心进行（用以解决距离数据密度不均匀的问题）, 而Adaptive Voxel Filter顾名思义用来自适应Voxel Filter相关配置（例如voxel_filter_size），处理后的数据组合完毕并从多个范围数据中过滤掉后，就进入Local SLAM。Local SLAM通过使用PoseExtrapolator的初始猜测进行匹配，将新的数据插入其当前子图结构中。PoseExtrapolator背后的想法是使用测距仪之外的其他传感器的传感器数据来预测下一次扫描应插入到子图中的位置，并且，通过调用</p>
<p>Ceres Solver将寻找最佳匹配位置问题转化成最小二乘问题进行优化，得到一个更匹配的子图。同时在Global SIAM中，它通过对子图进行扫描匹配扫描查找循环闭合约束。当Local SLAM生成其连续的子图时，对子图数据集的全局优化任务在后台运行。它的作用是在彼此之间重新布置子图，以便它们形成一个连贯的全局图。例如，此优化负责更改当前构建的轨迹，以根据循环闭合正确地对齐子图。整个算法过程大致如上。</p>
<p><img src="/.com//clip_image001.png" alt="img"></p>
<p>由各部分执行的功能和参数含义可知，我们通过调整TRAJECTORY_BUILDER_nD.max_range（25～30）来增加传感器传入的数据量，因为在Input Sensor Data中Cartographer通过bandpass filter，将数据的范围值保持在一定的最小和最大范围之间，同时对TRAJECTORY_BUILDER_nD.*adaptive_voxel_filter.max_length和TRAJECTORY_BUILDER_nD.*adaptive_voxel_filter.min_num_points也进行调整以适应传感器的值（前者3～4之间，后者150左右效果更好），对Local SLAM可接收的数据范围也要进行调整（例如TRAJECTORY_BUILDER_nD.submaps.num_range_data）。在LocalSLAM的建图过程中（通过预先将Global SLAM的优化关闭，POSE_GRAPH.optimize_every_n_nodes = 0），发现图中的旋转效果并不佳，因此，在CeresScanMatcher的优化过程中，增大TRAJECTORY_BUILDER_nD.ceres_scan_matcher.rotation_weight对优化此效果颇佳。</p>
<p><img src="/.com//image-20210608222319213.png" alt="image-20210608222319213"></p>
]]></content>
  </entry>
  <entry>
    <title>关于Mutable和Imutbale的等价性</title>
    <url>/2021/07/07/%E5%85%B3%E4%BA%8EMutable%E5%92%8CImutbale%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7/</url>
    <content><![CDATA[<p>对于Imutable类型的变量，它的观察等价性和行为等价性等价，而值得注意的是讨论等价性的时候考虑的是A空间而不是B空间，所以Imutable类型的变量是可以改变内部属性的值的，只要保证AF不变，有益的可变性是允许的。</p>
<p>但很经常容易搞混的一点就是Mutable类型的等价性，它分为观察等价性和行为等价性。观察等价性是指若使用Observer类型的方法来查看两个对象的值是一样的，那么可以判断是等价的对象。行为等价性是指使用对象的任意方法都能够保证对象的值相同，那么则认为两个对象等价。因此对于Mutable对象而言，行为等价性常常意味着两个对象指向的是同一个地址。而观察等价性它的限制则更加宽松一些。</p>
<p>注意：不同的Mutable类有不同的等价性标准，StringBuiler类的equals方法继承自Object，属于行为等价性。Collection类中的方法例如LIst，Set和Date遵循的是观察等价性。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Override和Overload的问题</title>
    <url>/2021/07/07/%E5%85%B3%E4%BA%8EOverride%E5%92%8COverload%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Overload指的是重载，它的要求是名字一样，但是参数一定不能一样,返回值可以不一样,具体调用哪一个重载方法在编译阶段的时候决定，编译会对参数类型进行检查，属于静态类型检查。</p>
<p>Override指的是重写，重写是在运行阶段进行检查，具体对象生成是在运行阶段完成的。因此： 重载看引用类型，重写看具体对象，</p>
<p>例如Animal 是dog 的父类， Animal a  = new dog() ,新建（new）一个Dog对象，定义一个Animal的引用a，用来指向Animal的子类对象dog，a的方法引用会作为一个列表来扫描，如果存在这个方法则在dog中调用相应的方法。</p>
<p>@override是为了让编译阶段检查该重写是否合法，参数列表必须相同，返回类型可以不通，但必须是被重写类型方法返回值的子类。@overload一方面为了提醒程序猿，另一方面也是能够让编译器检查是否合法重载。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
